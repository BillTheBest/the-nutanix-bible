<div data-type="part">
<h1>Book of Acropolis</h1>

<p class="definition"><strong>a·crop·o·lis  -  /ɘ ' kräpɘlis/  -  noun  -  data plane</strong>
<br/>
storage, compute and virtualization platform.
</p>

<section data-type="chapter">
<h1>Architecture</h1>
<p>Acropolis is a distributed multi-resource manager,&nbsp;orchestration platform and data plane.</p>

<p>It is broken down into three main components:</p>

<ul>
	<li>Distributed Storage Fabric (DSF)
	<ul>
		<li>This is at the core and birth of the Nutanix platform and expands upon the Nutanix Distributed Filesystem (NDFS).&nbsp; NDFS has now evolved from a distributed system pooling storage resources into a much larger and capable storage platform.</li>
	</ul>
	</li>
	<li>App Mobility Fabric (AMF)
	<ul>
		<li>Hypervisors abstracted the OS from hardware, and the AMF abstracts workloads (VMs, Storage, Containers, etc.) from the hypervisor.&nbsp; This will provide the ability to dynamically move the workloads between hypervisors, clouds, as well as provide the ability for Nutanix nodes to change hypervisors.</li>
	</ul>
	</li>
	<li>Hypervisor
	<ul>
		<li>A multi-purpose hypervisor based upon the CentOS KVM hypervisor.</li>
	</ul>
	</li>
</ul>

<p>Building upon the distributed nature of everything Nutanix does, we’re expanding this into the virtualization and resource management space.&nbsp; Acropolis is a back-end service that allows for workload and resource management, provisioning, and operations.&nbsp; Its goal is to abstract the facilitating resource (e.g., hypervisor, on-premise, cloud, etc.) from the workloads running, while providing a single “platform” to operate.&nbsp;</p>

<p>This gives workloads the ability to seamlessly move between hypervisors, cloud providers, and platforms.</p>

<p>The figure highlights an image illustrating the conceptual nature of Acropolis at various layers:</p>

<figure><img alt="High-level Acropolis Architecture" class="iimagesv2arch_acropolispng" src="imagesv2/arch_acropolis.png" />
<figcaption>High-level Acropolis Architecture</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Supported Hypervisors for VM Management</h1>

<p>Currently, the only fully supported hypervisor for VM management is Acropolis Hypervisor, however this may expand in the future. &nbsp;The Volumes API and read-only operations are still supported on all.</p>
</div>

<section data-type="sect1">
<h1>Acropolis Services</h1>

<p>An Acropolis Slave runs on every CVM with an elected Acropolis Master which is responsible for task scheduling, execution, IPAM, etc.&nbsp; Similar to other components which have a Master, if the Acropolis Master fails, a new one will be elected.</p>

<p>The role breakdown for each can be seen below:</p>

<ul>
	<li>Acropolis Master
	<ul>
		<li>Task scheduling &amp; execution</li>
		<li>Stat collection / publishing</li>
		<li>Network Controller (for hypervisor)</li>
		<li>VNC proxy (for hypervisor)</li>
		<li>HA (for hypervisor)</li>
	</ul>
	</li>
	<li>&nbsp;Acropolis Slave
	<ul>
		<li>Stat collection / publishing</li>
		<li>VNC proxy (for hypervisor)</li>
	</ul>
	</li>
</ul>

<p>Here we show a conceptual view of the Acropolis Master / Slave relationship:</p>

<figure><img alt="Acropolis Services" class="iimagesv2acrop_componentspng image" src="imagesv2/acrop_components.png" />
<figcaption>Acropolis Services</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Converged Platform</h1>

<p>For a video explanation you can watch the following video: <a href="https://youtu.be/OPYA5-V0yRo">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//OPYA5-V0yRo"></iframe></div>

<p>The Nutanix solution is a converged storage + compute solution which leverages local components and creates a distributed platform for virtualization, also known as a virtual computing platform. The solution is a bundled hardware + software appliance which houses 2 (6000/7000 series) or 4 nodes (1000/2000/3000/3050 series) in a 2U footprint.</p>

<p>Each node runs an industry-standard hypervisor (ESXi, KVM, Hyper-V currently) and the Nutanix Controller VM (CVM).&nbsp; The Nutanix CVM is what runs the Nutanix software and serves all of the I/O operations for the hypervisor and all VMs running on that host.&nbsp; For the Nutanix units running VMware vSphere, the SCSI controller, which manages the SSD and HDD devices, is directly passed to the CVM leveraging VM-Direct Path (Intel VT-d).&nbsp; In the case of Hyper-V, the storage devices are passed through to the CVM.</p>

<p>The following figure provides an example of what a typical node logically looks like:</p>

<figure><img alt="Converged Platform" class="iimagesv2converged_platformpng" src="imagesv2/converged_platform.png" />
<figcaption>Converged Platform</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Software-Defined</h1>

<p>As mentioned above (likely numerous times), the Nutanix platform is a software-based solution which ships as a bundled software + hardware appliance.&nbsp; The controller VM is where the vast majority of the Nutanix software and logic sits and was designed from the beginning to be an extensible and pluggable architecture. A key benefit to being software-defined and not relying upon any hardware offloads or constructs is around extensibility.&nbsp; As with any product life cycle,&nbsp;advancements and new features will always be introduced.&nbsp;</p>

<p>By not relying on any custom ASIC/FPGA or hardware capabilities, Nutanix can develop and deploy these new features through a simple software update.&nbsp; This means that the deployment of a new feature (e.g., deduplication) can be deployed by upgrading the current version of the Nutanix software.&nbsp; This also allows newer generation features to be deployed on legacy hardware models. For example, say you’re running a workload running an older version of Nutanix software on a prior generation hardware platform (e.g., 2400).&nbsp; The running software version doesn’t provide deduplication capabilities which your workload could benefit greatly from.&nbsp; To get these features, you perform a rolling upgrade of the Nutanix software version while the workload is running, and you now have deduplication.&nbsp; It’s really that easy.</p>

<p>Similar to features, the ability to create new “adapters” or interfaces into DSF is another key capability.&nbsp; When the product first shipped, it solely supported iSCSI for I/O from the hypervisor, this has now grown to include NFS and SMB.&nbsp; In the future, there is the ability to create new adapters for various workloads and hypervisors (HDFS, etc.).&nbsp; And again, all of this can be deployed via a software update. This is contrary to most legacy infrastructures, where a hardware upgrade or software purchase is normally required to get the “latest and greatest” features.&nbsp; With Nutanix, it’s different. Since all features are deployed in software, they can run on any hardware platform, any hypervisor, and be deployed through simple software upgrades.</p>

<p>The following figure shows a logical representation of what this software-defined controller framework looks like:</p>

<figure><img alt="Software-Defined Controller Framework" class="iimagesv2software_defined_controllerpng" src="imagesv2/software_defined_controller.png" />
<figcaption>Software-Defined Controller Framework</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Cluster Components</h1>

<p>For a visual explanation you can watch the following video:&nbsp;<a href="https://youtu.be/3v5RI_IbfV4">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//3v5RI_IbfV4"></iframe></div>

<p>The Nutanix platform is composed of the following high-level components:</p>

<figure><img alt="Nutanix Cluster Components" class="iimagesv2cluster_componentspng" src="imagesv2/cluster_components.png" />
<figcaption>Nutanix Cluster Components</figcaption>
</figure>

<h2>Cassandra</h2>

<ul>
	<li>Key Role: Distributed metadata store</li>
	<li>Description: Cassandra stores and manages all of the cluster metadata in a distributed ring-like manner based upon a heavily modified Apache Cassandra.&nbsp; The Paxos algorithm is utilized to enforce strict consistency.&nbsp; This service runs on every node in the cluster.&nbsp; The Cassandra is accessed via an interface called Medusa.</li>
</ul>

<h2>Zookeeper</h2>

<ul>
	<li>Key Role: Cluster configuration manager</li>
	<li>Description: Zookeeper stores all of the cluster configuration including hosts, IPs, state, etc. and is based upon Apache Zookeeper.&nbsp; This service runs on three nodes in the cluster, one of which is elected as a leader.&nbsp; The leader receives all requests and forwards them to its peers.&nbsp; If the leader fails to respond, a new leader is automatically elected.&nbsp;&nbsp; Zookeeper is accessed via an interface called Zeus.</li>
</ul>

<h2>Stargate</h2>

<ul>
	<li>Key Role: Data I/O manager</li>
	<li>Description: Stargate is responsible for all data management and I/O operations and is the main interface from the hypervisor (via NFS, iSCSI, or SMB).&nbsp; This service runs on every node in the cluster in order to serve localized I/O.</li>
</ul>

<h2>Curator</h2>

<ul>
	<li>Key Role: Map reduce cluster management and cleanup</li>
	<li>Description: Curator is responsible for managing and distributing tasks throughout the cluster, including disk balancing, proactive scrubbing, and many more items.&nbsp; Curator runs on every node and is controlled by an elected Curator Master who is responsible for the task and job delegation.&nbsp; There are two scan types for Curator, a full scan which occurs around every 6 hours and a partial scan which occurs every hour.</li>
</ul>

<h2>Prism</h2>

<ul>
	<li>Key Role: UI and API</li>
	<li>Description: Prism is the management gateway for component and administrators to configure and monitor the Nutanix cluster.&nbsp; This includes Ncli, the HTML5 UI, and REST API.&nbsp; Prism runs on every node in the cluster and uses an elected leader like all components in the cluster.</li>
</ul>

<h2>Genesis</h2>

<ul>
	<li>Key Role: Cluster component &amp; service manager</li>
	<li>Description:&nbsp; Genesis is a process which runs on each node and is responsible for any services interactions (start/stop/etc.) as well as for the initial configuration.&nbsp; Genesis is a process which runs independently of the cluster and does not require the cluster to be configured/running.&nbsp; The only requirement for Genesis to be running is that Zookeeper is up and running.&nbsp; The cluster_init and cluster_status pages are displayed by the Genesis process.</li>
</ul>

<h2>Chronos</h2>

<ul>
	<li>Key Role: Job and task scheduler</li>
	<li>Description: Chronos is responsible for taking the jobs and tasks resulting from a Curator scan and scheduling/throttling tasks among nodes.&nbsp; Chronos runs on every node and is controlled by an elected Chronos Master that is responsible for the task and job delegation and runs on the same node as the Curator Master.</li>
</ul>

<h2>Cerebro</h2>

<ul>
	<li>Key Role: Replication/DR manager</li>
	<li>Description: Cerebro is responsible for the replication and DR capabilities of DSF.&nbsp; This includes the scheduling of snapshots, the replication to remote sites, and the site migration/failover.&nbsp; Cerebro runs on every node in the Nutanix cluster and all nodes participate in replication to remote clusters/sites.</li>
</ul>

<h2>Pithos</h2>

<ul>
	<li>Key Role: vDisk configuration manager</li>
	<li>Description: Pithos is responsible for vDisk (DSF file) configuration data.&nbsp; Pithos runs on every node and is built on top of Cassandra.</li>
</ul>
</section>

<section data-type="sect1">
<h1>Drive Breakdown</h1>

<p>In this section, I’ll cover how the various storage devices (SSD / HDD) are broken down, partitioned, and utilized by the Nutanix platform. NOTE: All of the capacities used are in Base2 Gibibyte (GiB) instead of the Base10 Gigabyte (GB).&nbsp; Formatting of the drives with a filesystem and associated overheads has also been taken into account.</p>

<h2>SSD Devices</h2>

<p>SSD devices store a few key items which are explained in greater detail above:</p>

<ul>
	<li>Nutanix Home (CVM core)</li>
	<li>Cassandra (metadata storage)</li>
	<li>OpLog (persistent write buffer)</li>
	<li>Content Cache (SSD cache)</li>
	<li>Extent Store (persistent storage)</li>
</ul>

<p>The following figure shows an example of the storage breakdown for a Nutanix node’s SSD(s):</p>

<figure><img alt="SSD Drive Breakdown" class="iimagesv2drive_ssdpng" src="imagesv2/drive_ssd.png" />
<figcaption>SSD Drive Breakdown</figcaption>
</figure>

<p>NOTE: The sizing for OpLog is done dynamically as of release 4.0.1 which will allow the extent store portion to grow dynamically.&nbsp; The values used are assuming a completely utilized OpLog.&nbsp; Graphics and proportions aren’t drawn to scale.&nbsp; When evaluating the Remaining GiB capacities, do so from the top down.&nbsp; For example, the Remaining GiB to be used for the OpLog calculation would be after Nutanix Home and Cassandra have been subtracted from the formatted SSD capacity.</p>

<p>Most models ship with 1 or 2 SSDs, however the same construct applies for models shipping with more SSD devices. For example, if we apply this to an example 3060 or 6060 node which has 2 x 400GB SSDs, this would give us 100GiB of OpLog, 40GiB of Content Cache, and ~440GiB of Extent Store SSD capacity per node.</p>

<h2>HDD Devices</h2>

<p>Since HDD devices are primarily used for bulk storage, their breakdown is much simpler:</p>

<ul>
	<li>Curator Reservation (Curator storage)</li>
	<li>Extent Store (persistent storage)</li>
</ul>

<figure><img alt="HDD Drive Breakdown" class="iimagesv2drive_hddpng" src="imagesv2/drive_hdd.png" />
<figcaption>HDD Drive Breakdown</figcaption>
</figure>

<p>For example, if we apply this to an example 3060 node which has 4 x 1TB HDDs, this would give us 80GiB reserved for Curator and ~3.4TiB of Extent Store HDD capacity per node.</p>

<p>NOTE: the above values are accurate as of 4.0.1 and may vary by release.</p>
</section>
</section>

<section data-type="chapter">
<h1>Distributed Storage Fabric</h1>

<p>Together, a group of Nutanix nodes forms a distributed platform called the Acropolis Distributed Storage Fabric (DSF).&nbsp; DSF appears to the hypervisor like any centralized storage array, however all of the I/Os are handled locally to provide the highest performance.&nbsp; More detail on how these nodes form a distributed system can be found in the next section.</p>

<p>The following figure shows an example of how these Nutanix nodes form DSF:</p>

<figure class="large"><img alt="Distributed Storage Fabric Overview" class="iimagesv2dsf_overviewpng" src="imagesv2/dsf_overview.png" />
<figcaption>Distributed Storage Fabric Overview</figcaption>
</figure>

<section data-type="sect1">
<h1>Data Structure</h1>

<p>The Acropolis Distributed Storage Fabric is composed of the following high-level struct:</p>

<h2>Storage Pool</h2>

<ul>
	<li>Key Role: Group of physical devices</li>
	<li>Description: A storage pool is a group of physical storage devices including PCIe SSD, SSD, and HDD devices for the cluster.&nbsp; The storage pool can span multiple Nutanix nodes and is expanded as the cluster scales.&nbsp; In most configurations, only a single storage pool is leveraged.</li>
</ul>

<h2>Container</h2>

<ul>
	<li>Key Role: Group of VMs/files</li>
	<li>Description: A container is a logical segmentation of the Storage Pool and contains a group of VM or files (vDisks).&nbsp; Some configuration options (e.g., RF) are configured at the container level, however are applied at the individual VM/file level.&nbsp; Containers typically have a 1 to 1 mapping with a datastore (in the case of NFS/SMB).</li>
</ul>

<h2>vDisk</h2>

<ul>
	<li>Key Role: vDisk</li>
	<li>Description: A vDisk is any file over 512KB on DSF including .vmdks and VM hard disks.&nbsp; vDisks are composed of extents which are grouped and stored on disk as an extent group.</li>
</ul>

<p>The following figure shows how these map between DSF and the hypervisor:</p>

<figure><img alt="High-level Filesystem Breakdown" class="iimagesv2data_structure_1png" src="imagesv2/data_structure_1.png" />
<figcaption>High-level Filesystem Breakdown</figcaption>
</figure>

<h2>Extent</h2>

<ul>
	<li>Key Role: Logically contiguous data</li>
	<li>Description: An extent is a 1MB piece of logically contiguous data which consists of n number of contiguous blocks (varies depending on guest OS block size).&nbsp; Extents are written/read/modified on a sub-extent basis (aka slice) for granularity and efficiency.&nbsp; An extent’s slice may be trimmed when moving into the cache depending on the amount of data being read/cached.</li>
</ul>

<h2>Extent Group</h2>

<ul>
	<li>Key Role: Physically contiguous stored data</li>
	<li>Description: An extent group is a 1MB or 4MB piece of physically contiguous stored data.&nbsp; This data is stored as a file on the storage device owned by the CVM.&nbsp; Extents are dynamically distributed among extent groups to provide data striping across nodes/disks to improve performance.&nbsp; NOTE: as of 4.0, extent groups can now be either 1MB or 4MB depending on dedupe.</li>
</ul>

<p>The following figure shows how these structs relate between the various file systems:&nbsp;</p>

<figure><img alt="Low-level Filesystem Breakdown" class="iimagesv2data_structure_2png" src="imagesv2/data_structure_2.png" />
<figcaption>Low-level Filesystem Breakdown</figcaption>
</figure>

<p>Here is another graphical representation of how these units are related:</p>

<figure><img alt="Graphical Filesystem Breakdown" class="iimagesv2data_structure_3png" src="imagesv2/data_structure_3.png" />
<figcaption>Graphical Filesystem Breakdown</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>I/O Path Overview</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/SULqVPVXefY">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//SULqVPVXefY"></iframe></div>

<p>The Nutanix I/O path is composed of the following high-level components:</p>

<figure><img alt="DSF I/O Path" class="iimagesv2io_path_basepng" src="imagesv2/io_path_base.png" />
<figcaption>DSF I/O Path</figcaption>
</figure>

<h2>OpLog</h2>

<ul>
	<li>Key Role: Persistent write buffer</li>
	<li>Description: The OpLog is similar to a filesystem journal and is built to handle bursts of random writes, coalesce them, and then sequentially drain the data to the extent store.&nbsp; Upon a write, the OpLog is synchronously replicated to another n number of CVM’s OpLog before the write is acknowledged for data availability purposes.&nbsp; All CVM OpLogs partake in the replication and are dynamically chosen based upon load.&nbsp; The OpLog is stored on the SSD tier on the CVM to provide extremely fast write I/O performance, especially for random I/O workloads.&nbsp; For sequential workloads, the OpLog is bypassed and the writes go directly to the extent store.&nbsp; If data is currently sitting in the OpLog and has not been drained, all read requests will be directly fulfilled from the OpLog until they have been drained, where they would then be served by the extent store/content cache.&nbsp; For containers where fingerprinting (aka Dedupe) has been enabled, all write I/Os will be fingerprinted using a hashing scheme allowing them to be deduplicated based upon fingerprint in the content cache.</li>
</ul>

<h2>Extent Store</h2>

<ul>
	<li>Key Role: Persistent data storage</li>
	<li>Description: The Extent Store is the persistent bulk storage of DSF and spans SSD and HDD and is extensible to facilitate additional devices/tiers.&nbsp; Data entering the extent store is either being A) drained from the OpLog or B) is sequential in nature and has bypassed the OpLog directly.&nbsp; Nutanix ILM will determine tier placement dynamically based upon I/O patterns and will move data between tiers.</li>
</ul>

<h2>Content Cache</h2>

<ul>
	<li>Key Role: Dynamic read cache</li>
	<li>Description: The Content Cache is a deduplicated read cache which spans both the CVM’s memory and SSD.&nbsp; Upon a read request of data not in the cache (or based upon a particular fingerprint), the data will be placed into the single-touch pool of the Content Cache which completely sits in memory, where it will use LRU until it is evicted from the cache.&nbsp; Any subsequent read request will “move” (no data is actually moved, just cache metadata) the data into the memory portion of the multi-touch pool, which consists of both memory and SSD.&nbsp; From here there are two LRU cycles, one for the in-memory piece upon which eviction will move the data to the SSD section of the multi-touch pool where a new LRU counter is assigned.&nbsp; Any read request for data in the multi-touch pool will cause the data to go to the peak of the multi-touch pool where it will be given a new LRU counter.</li>
</ul>

<p>The following figure shows a high-level overview of the Content Cache:</p>

<figure><img alt="DSF Content Cache" class="iimagesv2content_cachepng" src="imagesv2/content_cache.png" />
<figcaption>DSF Content Cache</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Cache Granularity and Logic</h1>

<p>Data is brought into the cache at a 4K granularity and all caching is done real-time (e.g. no delay or batch process data to pull data into the cache).</p>
</div>

<h2>Extent Cache</h2>

<ul>
	<li>Key Role: In-memory read cache</li>
	<li>Description: The Extent Cache is an in-memory read cache that is completely in the CVM’s memory.&nbsp; This will store non-fingerprinted extents for containers where fingerprinting and deduplication are disabled.&nbsp; As of version 3.5, this is separate from the Content Cache, however these are merged in 4.5 with the unified cache.</li>
</ul>
</section>

<section data-type="sect1">
<h1>Data Protection</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/OWhdo81yTpk">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//OWhdo81yTpk"></iframe></div>

<p>The Nutanix platform currently uses a resiliency factor, also known as a replication factor (RF), and checksum to ensure data redundancy and availability in the case of a node or disk failure or corruption.&nbsp; As explained above, the OpLog acts as a staging area to absorb incoming writes onto a low-latency SSD tier.&nbsp; Upon being written to the local OpLog, the data is synchronously replicated to another one or two Nutanix CVM’s OpLog (dependent on RF) before being acknowledged (Ack) as a successful write to the host.&nbsp; This ensures that the data exists in at least two or three independent locations and is fault tolerant. NOTE: For RF3, a minimum of 5 nodes is required since metadata will be RF5.&nbsp;</p>

<p>Data RF is configured via Prism and is done at the container level. All nodes participate in OpLog replication to eliminate any “hot nodes”, ensuring linear performance at scale.&nbsp; While the data is being written, a checksum is computed and stored as part of its metadata. Data is then asynchronously drained to the extent store where the RF is implicitly maintained.&nbsp; In the case of a node or disk failure, the data is then re-replicated among all nodes in the cluster to maintain the RF.&nbsp; Any time the data is read, the checksum is computed to ensure the data is valid.&nbsp; In the event where the checksum and data don’t match, the replica of the data will be read and will replace the non-valid copy.</p>

<p>The following figure shows an example of what this logically looks like:&nbsp;</p>

<figure><img alt="DSF Data Protection" class="iimagesv2data_protectionpng fse fs" src="imagesv2/data_protection.png" />
<figcaption>DSF Data Protection</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Scalable Metadata</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/MlQczJhQI3U">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//MlQczJhQI3U"></iframe></div>

<p>Metadata is at the core of any intelligent system and is even more critical for any filesystem or storage array.&nbsp; In terms of DSF, there are a few key structs that are critical for its success: it has to be right 100% of the time (known as “strictly consistent”), it has to be scalable, and it has to perform at massive scale.&nbsp; As mentioned in the architecture section above, DSF utilizes a “ring-like” structure as a key-value store which stores essential metadata as well as other platform data (e.g., stats, etc.). In order to ensure metadata availability and redundancy a RF is utilized among an odd amount of nodes (e.g., 3, 5, etc.). Upon a metadata write or update, the row is written to a node in the ring and then replicated to n number of peers (where n is dependent on cluster size).&nbsp; A majority of nodes must agree before anything is committed, which is enforced using the Paxos algorithm.&nbsp; This ensures strict consistency for all data and metadata stored as part of the platform.</p>

<p>The following figure shows an example of a metadata insert/update for a 4 node cluster:</p>

<figure><img alt="Cassandra Ring Structure" class="iimagesv2metadata_1png" src="imagesv2/metadata_1.png" />
<figcaption>Cassandra Ring Structure</figcaption>
</figure>

<p>Performance at scale is also another important struct for DSF metadata.&nbsp; Contrary to traditional dual-controller or “master” models, each Nutanix node is responsible for a subset of the overall platform’s metadata.&nbsp; This eliminates the traditional bottlenecks by allowing metadata to be served and manipulated by all nodes in the cluster.&nbsp; A consistent hashing scheme is utilized to minimize the redistribution of keys during cluster size modifications (also known as&nbsp;“add/remove node”) When the cluster scales (e.g., from 4 to 8 nodes), the nodes are inserted throughout the ring between nodes for “block awareness” and reliability.</p>

<p>The following figure shows an example of the metadata “ring” and how it scales:</p>

<figure class="large"><img alt="Cassandra Scale Out" class="iimagesv2metadata_2png" src="imagesv2/metadata_2.png" />
<figcaption>Cassandra Scale Out</figcaption>
</figure>

<p>&nbsp;</p>
</section>

<section data-type="sect1">
<h1>Data Path Resiliency</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/SJIb_mTdMPg">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//SJIb_mTdMPg"></iframe></div>

<p>Reliability and resiliency are key, if not the most important concepts within DSF or any primary storage platform.&nbsp;</p>

<p>Contrary to traditional architectures which are built around the idea that hardware will be reliable, Nutanix takes a different approach: it expects hardware will eventually fail.&nbsp; By doing so, the system is designed to handle these failures in an elegant and non-disruptive manner.</p>

<p>NOTE: That doesn’t mean the hardware quality isn’t there, just a concept shift.&nbsp; The Nutanix hardware and QA teams undergo an exhaustive qualification and vetting process.</p>

<p><em>Potential levels of failure</em></p>

<p>Being a distributed system, DSF is built to handle component, service, and CVM failures, which can be characterized on a few levels:</p>

<ul>
	<li>Disk Failure</li>
	<li>CVM “Failure”</li>
	<li>Node Failure</li>
</ul>

<h2>Disk Failure</h2>

<p>A disk failure can be characterized as just that, a disk which has either been removed, had a dye failure, or is experiencing I/O errors and has been proactively removed.</p>

<p>VM impact:</p>

<ul>
	<li>HA event: <strong>No</strong></li>
	<li>Failed I/Os: <strong>No</strong></li>
	<li>Latency: <strong>No impact</strong></li>
</ul>

<p>In the event of a disk failure, a Curator scan (MapReduce Framework) will occur immediately. &nbsp;It will scan the metadata (Cassandra) to find the data previously hosted on the failed disk and the nodes / disks hosting the replicas.</p>

<p>Once it has found that data that needs to be “re-replicated”, it will distribute the replication tasks to the nodes throughout the cluster.&nbsp;</p>

<p>An important thing to highlight here is given how Nutanix distributes data and replicas across all nodes / CVMs / disks; all nodes / CVMs / disks will participate in the re-replication.&nbsp;</p>

<p>This substantially reduces the time required for re-protection, as the power of the full cluster can be utilized; the larger the cluster, the faster the re-protection.</p>

<h2>CVM “Failure”</h2>

<p>A CVM "failure” can be characterized as a CVM power action causing the CVM to be temporarily unavailable.&nbsp; The system is designed to transparently handle these gracefully.&nbsp; In the event of a failure, I/Os will be re-directed to other CVMs within the cluster.&nbsp; The mechanism for this will vary by hypervisor.&nbsp;</p>

<p>The rolling upgrade process actually leverages this capability as it will upgrade one CVM at a time, iterating through the cluster.</p>

<p>VM impact:</p>

<ul>
	<li>HA event: <strong>No</strong></li>
	<li>Failed I/Os: <strong>No</strong></li>
	<li>Latency: <strong>Potentially higher given I/Os over the network</strong></li>
</ul>

<p>In the event of a CVM "failure” the I/O which was previously being served from the down CVM, will be forwarded to other CVMs throughout the cluster.&nbsp; ESXi and Hyper-V handle this via a process called CVM Autopathing, which leverages HA.py (like “happy”), where it will modify the routes to forward traffic going to the internal address (192.168.5.2) to the external IP of other CVMs throughout the cluster.&nbsp; This enables the datastore to remain intact, just the CVM responsible for serving the I/Os is remote.</p>

<p>Once the local CVM comes back up and is stable, the route would be removed and the local CVM would take over all new I/Os.</p>

<p>In the case of KVM, iSCSI multi-pathing is leveraged where the primary path is the local CVM and the two other paths would be remote.&nbsp; In the event where the primary path fails, one of the other paths will become active.</p>

<p>Similar to Autopathing with ESXi and Hyper-V, when the local CVM comes back online, it’ll take over as the primary path.</p>

<h2>Node Failure</h2>

<p>VM Impact:</p>

<ul>
	<li>HA event: <strong>Yes</strong></li>
	<li>Failed I/Os: <strong>No</strong></li>
	<li>Latency: <strong>No impact</strong></li>
</ul>

<p>In the event of a node failure, a VM HA event will occur restarting the VMs on other nodes throughout the virtualization cluster.&nbsp; Once restarted, the VMs will continue to perform I/Os as usual which will be handled by their local CVMs.</p>

<p>Similar to the case of a disk failure above, a Curator scan will find the data previously hosted on the node and its respective replicas.</p>

<p>Similar to the disk failure scenario above, the same process will take place to re-protect the data, just for the full node (all associated disks).</p>

<p>In the event where the node remains down for a prolonged period of time, the down CVM will be removed from the metadata ring.&nbsp; It will be joined back into the ring after it has been up and stable for a duration of time.</p>
</section>

<section data-type="sect1">
<h1>Compression</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/ERDqOCzDcQY">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//ERDqOCzDcQY"></iframe></div>

<p>The Nutanix Capacity Optimization Engine (COE) is responsible for performing data transformations to increase data efficiency on disk.&nbsp; Currently compression is one of the key features of the COE to perform data optimization. DSF provides both in-line and post-process flavors of compression to best suit the customer’s needs and type of data.&nbsp;</p>

<p>In-line compression will compress sequential streams of data or large I/O sizes in memory before it is written to disk, while post-process compression will initially write the data as normal (in an un-compressed state) and then leverage the Curator framework to compress the data cluster wide. When in-line compression is enabled but the I/Os are random in nature, the data will be written un-compressed in the OpLog, coalesced, and then compressed in memory before being written to the Extent Store. The Google Snappy compression library is leveraged which provides good compression ratios with minimal computational overhead and extremely fast compression / decompression rates.</p>

<p>The following figure shows an example of how in-line compression interacts with the DSF write I/O path:</p>

<figure><img alt="Inline Compression I/O Path" class="iimagesv2compression_1png" src="imagesv2/compression_1.png" />
<figcaption>Inline Compression I/O Path</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>Almost always use inline compression (compression delay = 0) as it will only compress larger / sequential writes and not impact random write performance.</p>

<p>
	Inline compression also pairs perfectly with erasure coding.
</p>

</div>

<p>For post-process compression, all new write I/O is written in an un-compressed state and follows the normal DSF I/O path.&nbsp; After the compression delay (configurable) is met and the data has become cold (down-migrated to the HDD tier via ILM), the data is eligible to become compressed. Post-process compression uses the Curator MapReduce framework and all nodes will perform compression tasks.&nbsp; Compression tasks will be throttled by Chronos.</p>

<p>The following figure shows an example of how post-process compression interacts with the DSF write I/O path:</p>

<figure><img alt="Post-process Compression I/O Path" class="iimagesv2compression_2png" src="imagesv2/compression_2.png" />
<figcaption>Post-process Compression I/O Path</figcaption>
</figure>

<p>For read I/O, the data is first decompressed in memory and then the I/O is served.&nbsp; For data that is heavily accessed, the data will become decompressed in the HDD tier and can then leverage ILM to move up to the SSD tier as well as be stored in the cache.</p>

<p>The following figure shows an example of how decompression interacts with the DSF I/O path during read:</p>

<figure><img alt="Decompression I/O Path" class="iimagesv2compression_3png" src="imagesv2/compression_3.png" />
<figcaption>Decompression I/O Path</figcaption>
</figure>

<p>You can view the current compression rates via Prism on the Storage &gt; Dashboard page.</p>
</section>

<section data-type="sect1">
<h1>Erasure Coding</h1>

<p>The Nutanix platform relies leverages factor (RF) for data protection and availability.&nbsp; This method provides the highest degree of availability because it does not require reading from more than one storage location or data re-computation on failure.&nbsp; However, this does come at the cost of storage resources as full copies are required.&nbsp;</p>

<p>To provide a balance between availability while reducing the amount of storage required, DSF provides the ability to encode data using erasure codes (EC).</p>

<p>Similar to the concept of RAID (levels 4, 5, 6, etc.) where parity is calculated, EC encodes a strip of data blocks on different nodes and calculates parity.&nbsp; In the event of a host and/or disk failure, the parity can be leveraged to calculate any missing data blocks (decoding).&nbsp; In the case of DSF, the data block is an extent group and each data block must be on a different node and belong to a different vDisk.</p>

<p>The number of data and parity blocks in a strip is configurable based upon the desired failures to tolerate.&nbsp; The configuration is commonly referred to as the number of &lt;data blocks&gt;/&lt;number of parity blocks&gt;.</p>

<p>For example, “RF2 like” availability (e.g., N+1) could consist of 3 or 4 data blocks and 1 parity block in a strip (e.g., 3/1 or 4/1).&nbsp; “RF3 like” availability (e.g. N+2) could consist of 3 or 4 data blocks and 2 parity blocks in a strip (e.g. 3/2 or 4/2).</p>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>You can override the default strip size (4/1 for “RF2 like” or 4/2 for “RF3 like”) via NCLI ‘ctr [create / edit] … erasure-code=&lt;N&gt;/&lt;K&gt;’ where N is the number of data blocks and K is the number of parity blocks.</p>
</div>

<p>The expected overhead can be calculated as &lt;# parity blocks&gt; / &lt;# data blocks&gt;.&nbsp; For example, a 4/1 strip has a 25% overhead or 1.25X compared to the 2X of RF2.&nbsp; A 4/2 strip has a 50% overhead or 1.5X compared to the 3X of RF3.</p>

<p>The following table characterizes the encoded strip sizes and example overheads:</p>

<table>
  <tr>
    <th></th>
    <th colspan="2"><center>FT1 (RF2 equiv.)</center></th>
    <th colspan="2"><center>FT2 (RF3 equiv.)</center></th>
  </tr>
  <tr>
    <td>Cluster Size<br/>(nodes)</td>
    <td>EC Strip Size<br/>(data/parity blocks)</td>
    <td>EC Overhead<br/>(vs. 2X of RF2)</td>
    <td>EC Strip Size<br/>(data/parity)</td>
    <td>EC Overhead<br/>(vs. 3X of RF3)</td>
  </tr>
  <tr>
    <td>4</td>
    <td>2/1</td>
    <td>1.5X</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>5</td>
    <td>3/1</td>
    <td>1.33X</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>6</td>
    <td>4/1</td>
    <td>1.25X</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>7+</td>
    <td>4/1</td>
    <td>1.25X</td>
    <td>4/2</td>
    <td>1.5X</td>
  </tr>
</table>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>It is always recommended to have a cluster size which has at least 1 more node than the combined strip size (data + parity) to allow for rebuilding of the strips in the event of a node failure.  This eliminates any computation overhead on reads once the strips have been rebuilt (automated via Curator).  For example, a 4/1 strip should have at least 6 nodes in the cluster.  The previous table follows this best practice.</p>
</div>

<p>The encoding is done post-process and leverages the Curator MapReduce framework for task distribution.&nbsp; Since this is a post-process framework, the traditional write I/O path is unaffected.</p>

<p>A normal environment using RF would look like the following:</p>

<figure><img alt="Typical DSF RF Data Layout" class="iimagesv2ec_1png" src="imagesv2/ec_1.png" />
<figcaption>Typical DSF RF Data Layout</figcaption>
</figure>

<p>In this scenario, we have a mix of both RF2 and RF3 data whose primary copies are local and replicas are distributed to other nodes throughout the cluster.</p>

<p>When a Curator full scan runs, it will find eligible extent groups which are available to become encoded.  Eligible extent groups must be "write-cold" meaning they haven't been written to for &gt; 1 hour. After the eligible candidates are found, the encoding tasks will be distributed and throttled via Chronos.</p>

<p>The following figure shows an example 4/1 and 3/2 strip:</p>

<figure><img alt="DSF Encoded Strip - Pre-savings" class="iimagesv2ec_2png" src="imagesv2/ec_2.png" />
<figcaption>DSF Encoded Strip - Pre-savings</figcaption>
</figure>

<p>Once the data has been successfully encoded (strips and parity calculation), the replica extent groups are then removed.</p>

<p>The following figure shows the environment after EC has run with the storage savings:</p>

<figure><img alt="DSF Encoded Strip - Post-savings" class="iimagesv2ec_3png" src="imagesv2/ec_3.png" />
<figcaption>DSF Encoded Strip - Post-savings</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>Erasure Coding pairs perfectly with inline compression which will add to the storage savings.  I leverage inline compression + EC in my environments.</p>
</div>
</section>

<section data-type="sect1">
<h1>Elastic Dedupe Engine</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/C-rp13cDpNw">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//C-rp13cDpNw"></iframe></div>

<p>The Elastic Dedupe Engine is a software-based feature of DSF which allows for data deduplication in the capacity (HDD) and performance (SSD/Memory) tiers.&nbsp; Streams of data are fingerprinted during ingest using a SHA-1 hash at a 16K granularity.&nbsp; This fingerprint is only done on data ingest and is then stored persistently as part of the written block’s metadata.&nbsp; NOTE: Initially a 4K granularity was used for fingerprinting, however after testing 16K offered the best blend of deduplication with reduced metadata overhead.&nbsp; Deduplicated data is pulled into the content cache at a 4K granularity.</p>

<p>Contrary to traditional approaches which utilize background scans requiring the data to be re-read, Nutanix performs the fingerprint in-line on ingest.&nbsp; For duplicate data that can be deduplicated in the capacity tier, the data does not need to be scanned or re-read, essentially duplicate copies can be removed.</p>

<p>
	To make the metadata overhead more efficient, fingerprint refcounts are monitored to track dedupability.  Fingerprints with low refcounts will be discarded to minimize the metadata overhead. To minimize fragmentation full extents will be preferred for capacity tier deduplication.
</p>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>Use performance tier deduplication on your base images (you can manually fingerprint them using vdisk_manipulator) to take advantage of the content cache.</p>

<p>Use capacity tier deduplication for P2V / V2V,&nbsp;when using Hyper-V since ODX does a full data copy, or when doing cross-container clones (not usually recommended as a single container is preferred).</p>

<p>In most other cases compression will yield the highest capacity savings and should be used instead.</p>
</div>

<p>The following figure shows an example of how the Elastic Dedupe Engine scales and handles local VM I/O requests:</p>

<figure class="large"><img alt="Elastic Dedupe Engine - Scale" class="iimagesv2dedup_1png" src="imagesv2/dedup_1.png" />
<figcaption>Elastic Dedupe Engine - Scale</figcaption>
</figure>

<p>Fingerprinting is done during data ingest of data with an I/O size of 64K or greater.&nbsp; Intel acceleration is leveraged for the SHA-1 computation which accounts for very minimal CPU overhead.&nbsp; In cases where fingerprinting is not done during ingest (e.g., smaller I/O sizes), fingerprinting can be done as a background process. The Elastic Deduplication Engine spans both the capacity disk tier (HDD), but also the performance tier (SSD/Memory).&nbsp; As duplicate data is determined, based upon multiple copies of the same fingerprints, a background process will remove the duplicate data using the DSF Map Reduce framework (Curator). For data that is being read, the data will be pulled into the DSF Content Cache which is a multi-tier/pool cache.&nbsp; Any subsequent requests for data having the same fingerprint will be pulled directly from the cache.&nbsp; To learn more about the Content Cache and pool structure, please refer to the ‘Content Cache’ sub-section in the I/O path overview.</p>

<div data-type="note" class="note">
<h1>Fingerprinted vDisk Offsets</h1>
<p>
	Prior to 4.5 only the first 12GB of a vDisk was eligible to be fingerprinted.  This was done to maintain a smaller metadata footprint and since the OS is normally the most common data.  As of 4.5 this has increased to 24GB due to higher metadata efficiencies.
</p>
</div>

<p>The following figure shows an example of how the Elastic Dedupe Engine interacts with the DSF I/O path:</p>

<figure><img alt="EDE I/O Path" class="iimagesv2dedup_2png" src="imagesv2/dedup_2.png" />
<figcaption>EDE I/O Path</figcaption>
</figure>

<p>You can view the current deduplication rates via Prism on the Storage &gt; Dashboard page.</p>

<div data-type="note" class="note">
<h1>Dedup + Compression</h1>

<p>
	As of 4.5 both deduplication and compression can be enabled on the same container.  However, unless the data is dedupable (conditions explained earlier in section), stick with compression.
</p>

</div>
</section>

<section data-type="sect1">
<h1>Storage Tiering and Prioritization</h1>

<p>The Disk Balancing section above talked about how storage capacity was pooled among all nodes in a Nutanix cluster and that ILM would be used to keep hot data local.&nbsp; A similar concept applies to disk tiering, in which the cluster’s SSD and HDD tiers are cluster-wide and DSF ILM is responsible for triggering data movement events. A local node’s SSD tier is always the highest priority tier for all I/O generated by VMs running on that node, however all of the cluster’s SSD resources are made available to all nodes within the cluster.&nbsp; The SSD tier will always offer the highest performance and is a very important thing to manage for hybrid arrays.</p>

<p>The tier prioritization can be classified at a high-level by the following:</p>

<figure><img alt="DSF Tier Prioritization" class="iimagesv2tiering_1png" src="imagesv2/tiering_1.png" />
<figcaption>DSF Tier Prioritization</figcaption>
</figure>

<p>Specific types of resources (e.g. SSD, HDD, etc.) are pooled together and form a cluster wide storage tier.&nbsp; This means that any node within the cluster can leverage the full tier capacity, regardless if it is local or not.</p>

<p>The following figure shows a high level example of what this pooled tiering looks like:</p>

<figure class="large"><img alt="DSF Cluster-wide Tiering" class="iimagesv2tiering_2png" src="imagesv2/tiering_2.png" />
<figcaption>DSF Cluster-wide Tiering</figcaption>
</figure>

<p>A common question is what happens when a local node’s SSD becomes full?&nbsp; As mentioned in the Disk Balancing section, a key concept is trying to keep uniform utilization of devices within disk tiers.&nbsp; In the case where a local node’s SSD utilization is high, disk balancing will kick in to move the coldest data on the local SSDs to the other SSDs throughout the cluster.&nbsp; This will free up space on the local SSD to allow the local node to write to SSD locally instead of going over the network.&nbsp; A key point to mention is that all CVMs and SSDs are used for this remote I/O to eliminate any potential bottlenecks and remediate some of the hit by performing I/O over the network.</p>

<figure class="large"><img alt="DSF Cluster-wide Tier Balancing" class="iimagesv2tiering_3png" src="imagesv2/tiering_3.png" />
<figcaption>DSF Cluster-wide Tier Balancing</figcaption>
</figure>

<p>The other case is when the overall tier utilization breaches a specific threshold [curator_tier_usage_ilm_threshold_percent (Default=75)] where DSF ILM will kick in and as part of a Curator job will down-migrate data from the SSD tier to the HDD tier.&nbsp; This will bring utilization within the threshold mentioned above or free up space by the following amount [curator_tier_free_up_percent_by_ilm (Default=15)], whichever is greater. The data for down-migration is chosen using last access time. In the case where the SSD tier utilization is 95%, 20% of the data in the SSD tier will be moved to the HDD tier (95% –&gt; 75%).&nbsp;</p>

<p>However, if the utilization was 80%, only 15% of the data would be moved to the HDD tier using the minimum tier free up amount.</p>

<figure class="large"><img alt="DSF Tier ILM" class="iimagesv2tiering_4png" src="imagesv2/tiering_4.png" />
<figcaption>DSF Tier ILM</figcaption>
</figure>

<p>DSF ILM will constantly monitor the I/O patterns and (down/up) migrate data as necessary as well as bring the hottest data local regardless of tier.</p>
</section>

<section data-type="sect1">
<h1>Disk Balancing</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/atbkgrmpVNo">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//atbkgrmpVNo"></iframe></div>

<p>DSF is designed to be a very dynamic platform which can react to various workloads as well as allow heterogeneous node types: compute heavy (3050, etc.) and storage heavy (60X0, etc.) to be mixed in a single cluster.&nbsp; Ensuring uniform distribution of data is an important item when mixing nodes with larger storage capacities. DSF has a native feature, called disk balancing, which is used to ensure uniform distribution of data throughout the cluster.&nbsp; Disk balancing works on a node’s utilization of its local storage capacity and is integrated with DSF ILM.&nbsp; Its goal is to keep utilization uniform among nodes once the utilization has breached a certain threshold.</p>

<p>The following figure shows an example of a mixed cluster (3050 + 6050) in an “unbalanced” state:</p>

<figure class="large"><img alt="Disk Balancing - Unbalanced State" class="iimagesv2disk_balancing_1png" src="imagesv2/disk_balancing_1.png" />
<figcaption>Disk Balancing - Unbalanced State</figcaption>
</figure>

<p>Disk balancing leverages the DSF Curator framework and is run as a scheduled process as well as when a threshold has been breached (e.g., local node capacity utilization &gt; n %).&nbsp; In the case where the data is not balanced, Curator will determine which data needs to be moved and will distribute the tasks to nodes in the cluster. In the case where the node types are homogeneous (e.g., 3050), utilization should be fairly uniform. However, if there are certain VMs running on a node which are writing much more data than others, there can become a skew in the per node capacity utilization.&nbsp; In this case, disk balancing would run and move the coldest data on that node to other nodes in the cluster. In the case where the node types are heterogeneous (e.g., 3050 + 6020/50/70), or where a node may be used in a “storage only” mode (not running any VMs), there will likely be a requirement to move data.</p>

<p>The following figure shows an example the mixed cluster after disk balancing has been run in a “balanced” state:</p>

<figure class="large"><img alt="Disk Balancing - Balanced State" class="iimagesv2disk_balancing_2png" src="imagesv2/disk_balancing_2.png" />
<figcaption>Disk Balancing - Balanced State</figcaption>
</figure>

<p>In some scenarios, customers might run some nodes in a “storage-only” state where only the CVM will run on the node whose primary purpose is bulk storage capacity.&nbsp; In this case, the full node's memory can be added to the CVM to provide a much larger read cache.</p>

<p>The following figure shows an example of how a storage only node would look in a mixed cluster with disk balancing moving data to it from the active VM nodes:</p>

<figure class="large"><img alt="Disk Balancing - Storage Only Node" class="iimagesv2disk_balancing_3png" src="imagesv2/disk_balancing_3.png" />
<figcaption>Disk Balancing - Storage Only Node</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Availability Domains</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/LDaNY9AJDn8">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//LDaNY9AJDn8"></iframe></div>

<p>Availability Domains (aka node/block/rack awareness) is a key struct for distributed systems to abide by for determining component and data placement.&nbsp; DSF is currently node and block aware, however this will increase to rack aware as cluster sizes grow.&nbsp; Nutanix refers to a “block” as the chassis which contains either one, two, or four server “nodes”. NOTE: A minimum of 3 blocks must be utilized for block awareness to be activated, otherwise node awareness will be defaulted to.&nbsp;</p>

<p>It is recommended to utilized uniformly populated blocks to ensure block awareness is enabled.&nbsp; Common scenarios and the awareness level utilized can be found at the bottom of this section.&nbsp; The 3-block requirement is due to ensure quorum. For example, a 3450 would be a block which holds 4 nodes.&nbsp; The reason for distributing roles or data across blocks is to ensure if a block fails or needs maintenance the system can continue to run without interruption.&nbsp; NOTE: Within a block, the redundant PSU and fans are the only shared components Awareness can be broken into a few key focus areas:</p>

<ul>
	<li>Data (The VM data)</li>
	<li>Metadata (Cassandra)</li>
	<li>Configuration Data (Zookeeper)</li>
</ul>

<h2>Data</h2>

<p>With DSF, data replicas will be written to other blocks in the cluster to ensure that in the case of a block failure or planned downtime, the data remains available.&nbsp; This is true for both RF2 and RF3 scenarios, as well as in the case of a block failure. An easy comparison would be “node awareness”, where a replica would need to be replicated to another node which will provide protection in the case of a node failure.&nbsp; Block awareness further enhances this by providing data availability assurances in the case of block outages.</p>

<p>The following figure shows how the replica placement would work in a 3-block deployment:</p>

<figure><img alt="Block Aware Replica Placement" class="iimagesv2avail_dom_1png" src="imagesv2/avail_dom_1.png" />
<figcaption>Block Aware Replica Placement</figcaption>
</figure>

<p>In the case of a block failure, block awareness will be maintained and the re-replicated blocks will be replicated to other blocks within the cluster:</p>

<figure><img alt="Block Failure Replica Placement" class="iimagesv2avail_dom_2png" src="imagesv2/avail_dom_2.png" />
<figcaption>Block Failure Replica Placement</figcaption>
</figure>

<div data-type="note" class="note">
	<h1>Data Awareness Conditions</h1>
<p>Below we breakdown some common scenarios and what level of awareness will be utilized:</p>

<ul>
	<li>&lt; 3 blocks: <strong>NODE</strong> awareness</li>
	<li>3+ blocks uniformly populated: <strong>BLOCK + NODE</strong> awareness</li>
	<li>3+ blocks not uniformly populated
	<ul>
		<li>If SSD <strong>or</strong> HDD tier variance between blocks is &gt; max variance: <strong>NODE (pre 4.5) or BEST EFFORT BLOCK (post 4.5)</strong> awareness</li>
		<li>If SSD and HDD tier variance between blocks is &lt; max variance: <strong>BLOCK + NODE</strong> awareness</li>
	</ul>
	</li>
</ul>

<p>Max tier variance is calculated as: 100 / (RF+1)</p>
<ul>
	<li>E.g., 33% for RF2 or 25% for RF3</li>
</ul>
</div>

<h2>Metadata</h2>

<p>As mentioned in the Scalable Metadata section above, Nutanix leverages a heavily modified Cassandra platform to store metadata and other essential information.&nbsp; Cassandra leverages a ring-like structure and replicates to n number of peers within the ring to ensure data consistency and availability.</p>

<p>The following figure shows an example of the Cassandra's ring for a 12-node cluster:</p>

<figure><img alt="12 Node Cassandra Ring" class="iimagesv2avail_dom_3png fse fs image" src="imagesv2/avail_dom_3.png" style="width: 50%; height: 50%" />
<figcaption>12 Node Cassandra Ring</figcaption>
</figure>

<p>Cassandra peer replication iterates through nodes in a clockwise manner throughout the ring.&nbsp; With block awareness, the peers are distributed among the blocks to ensure no two peers are on the same block.</p>

<p>The following figure shows an example node layout translating the ring above into the block based layout:</p>

<figure><img alt="Cassandra Node Block Aware Placement" class="iimagesv2avail_dom_4png" src="imagesv2/avail_dom_4.png" />
<figcaption>Cassandra Node Block Aware Placement</figcaption>
</figure>

<p>With this block-aware nature, in the event of a block failure there will still be at least two copies of the data (with Metadata RF3 – In larger clusters RF5 can be leveraged).</p>

<p>The following figure shows an example of all of the nodes replication topology to form the ring (yes – it’s a little busy):</p>

<figure><img alt="Full Cassandra Node Block Aware Placement" class="iimagesv2avail_dom_5png" src="imagesv2/avail_dom_5.png" />
<figcaption>Full Cassandra Node Block Aware Placement</figcaption>
</figure>

<div data-type="note" class="note">
	<h1>Metadata Awareness Conditions</h1>
<p>Below we breakdown some common scenarios and what level of awareness will be utilized:</p>

<ul>
	<li>FT1 (Data RF2 / Metadata RF3) will be block aware if:
		<ul>
			<li>
				&gt; 3 blocks
			</li>
			<li>Let X be the number of nodes in the block with max nodes. Then, the remaining blocks should have at least 2X nodes.
				<ul>
					<li>
						Example: 4 blocks with 2,3,4,2 nodes per block respectively.
						<ul>
							<li>
								The max node block has 4 nodes which means the other 3 blocks should have 2x4 (8) nodes.  In this case it <strong>WOULD NOT</strong> be block aware as the remaining blocks only have 7 nodes.
							</li>
						</ul>
					</li>
					<br/>
					<li>
						Example: 4 blocks with 3,3,4,3 nodes per block respectively.
						<ul>
							<li>
								The max node block has 4 nodes which means the other 3 blocks should have 2x4==8 nodes.  In this case it <strong>WOULD</strong> be block aware as the remaining blocks have 9 nodes which is above our minimum.
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
	<li>FT2 (Data RF3 / Metadata RF5) will be block aware if:
		<ul>
			<li>
				&gt; 5 blocks
			</li>
			<li>Let X be the number of nodes in the block with max nodes. Then, the remaining blocks should have at least 4X nodes.
				<ul>
					<li>
						Example: 6 blocks with 2,3,4,2,3,3 nodes per block respectively.
						<ul>
							<li>
							The max node block has 4 nodes which means the other 3 blocks should have 4x4==16 nodes.  In this case it <strong>WOULD NOT</strong> be block aware as the remaining blocks only have 13 nodes.
							</li>
						</ul>
						</li>
					<br/>
					<li>
						Example: 6 blocks with 2,4,4,4,4,4 nodes per block respectively.
						<ul>
							<li>
								The max node block has 4 nodes which means the other 3 blocks should have 4x4==16 nodes.  In this case it <strong>WOULD</strong> be block aware as the remaining blocks have  18 nodes which is above our minimum.
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</li>
</ul>
</div>

<h2>Configuration Data</h2>

<p>Nutanix leverages Zookeeper to store essential configuration data for the cluster.&nbsp; This role is also distributed in a block-aware manner to ensure availability in the case of a block failure.</p>

<p>The following figure shows an example layout showing 3 Zookeeper nodes distributed in a block-aware manner:</p>

<figure><img alt="Zookeeper Block Aware Placement" class="iimagesv2avail_dom_6png" src="imagesv2/avail_dom_6.png" />
<figcaption>Zookeeper Block Aware Placement</figcaption>
</figure>

<p>In the event of a block outage, meaning one of the Zookeeper nodes will be gone, the Zookeeper role would be transferred to another node in the cluster as shown below:</p>

<figure><img alt="Zookeeper Placement Block Failure" class="iimagesv2avail_dom_7png" src="imagesv2/avail_dom_7.png" />
<figcaption>Zookeeper Placement Block Failure</figcaption>
</figure>

<p>When the block comes back online, the Zookeeper role would be transferred back to maintain block awareness.</p>

<p>NOTE: Prior to 4.5, this migration was not automatic and must be done manually.</p>

</section>

<section data-type="sect1">
<h1>Snapshots and Clones</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/uK5wWR44UYE">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//uK5wWR44UYE"></iframe></div>

<p>DSF provides native support for offloaded snapshots and clones which can be leveraged via VAAI, ODX, ncli, REST, Prism, etc.&nbsp; Both the snapshots and clones leverage the redirect-on-write algorithm which is the most effective and efficient. As explained in the Data Structure section above, a virtual machine consists of files (vmdk/vhdx) which are vDisks on the Nutanix platform.&nbsp;</p>

<p>A vDisk is composed of extents which are logically contiguous chunks of data, which are stored within extent groups which are physically contiguous data stored as files on the storage devices. When a snapshot or clone is taken, the base vDisk is marked immutable and another vDisk is created as read/write.&nbsp; At this point, both vDisks have the same block map, which is a metadata mapping of the vDisk to its corresponding extents. Contrary to traditional approaches which require traversal of the snapshot chain (which can add read latency), each vDisk has its own block map.&nbsp; This eliminates any of the overhead normally seen by large snapshot chain depths and allows you to take continuous snapshots without any performance impact.</p>

<p>The following figure shows an example of how this works when a snapshot is taken (NOTE: I need to give some credit to NTAP as a base for these diagrams, as I thought their representation was the clearest):</p>

<figure class="large"><img alt="Example Snapshot Block Map" class="iimagesv2snap_1png" src="imagesv2/snap_1.png" />
<figcaption>Example Snapshot Block Map</figcaption>
</figure>

<p>The same method applies when a snapshot or clone of a previously snapped or cloned vDisk is performed:</p>

<figure class="large"><img alt="Multi-snap Block Map and New Write" class="iimagesv2snap_2png" src="imagesv2/snap_2.png" />
<figcaption>Multi-snap Block Map and New Write</figcaption>
</figure>

<p>The same methods are used for both snapshots and/or clones of a VM or vDisk(s).&nbsp; When a VM or vDisk is cloned, the current block map is locked and the clones are created.&nbsp; These updates are metadata only, so no I/O actually takes place.&nbsp; The same method applies for clones of clones; essentially the previously cloned VM acts as the “Base vDisk” and upon cloning, that block map is locked and two “clones” are created: one for the VM being cloned and another for the new clone.&nbsp;</p>

<p>They both inherit the prior block map and any new writes/updates would take place on their individual block maps.</p>

<figure><img alt="Multi-Clone Block Maps" class="iimagesv2snap_3png" src="imagesv2/snap_3.png" />
<figcaption>Multi-Clone Block Maps</figcaption>
</figure>

<p>As mentioned previously, each VM/vDisk has its own individual block map.&nbsp; So in the above example, all of the clones from the base VM would now own their block map and any write/update would occur there.&nbsp;</p>

<p>The following figure shows an example of what this looks like:</p>

<figure><img alt="Clone Block Maps - New Write" class="iimagesv2snap_4png" src="imagesv2/snap_4.png" />
<figcaption>Clone Block Maps - New Write</figcaption>
</figure>

<p>Any subsequent clones or snapshots of a VM/vDisk would cause the original block map to be locked and would create a new one for R/W access.</p>
</section>

<section data-type="sect1">
<h1>Replication and Multi-Site Disaster Recovery</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/AoKwKI7CXIM">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//AoKwKI7CXIM"></iframe></div>

<p>Nutanix provides native DR and replication capabilities, which build upon the same features explained in the Snapshots &amp; Clones section.&nbsp; Cerebro is the component responsible for managing the DR and replication in DSF.&nbsp; Cerebro runs on every node and a Cerebro master is elected (similar to NFS master) and is responsible for managing replication tasks.&nbsp; In the event the CVM acting as Cerebro master fails, another is elected and assumes the role.&nbsp; The Cerebro page can be found on &lt;CVM IP&gt;:2020. The DR function can be broken down into a few key focus areas:</p>

<ul>
	<li>Replication Topologies</li>
	<li>Implementation Constructs</li>
	<li>Replication Lifecycle</li>
	<li>Global Deduplication</li>
</ul>

<h2>Replication Topologies</h2>

<p>Traditionally, there are a few key replication topologies: Site to site, hub and spoke, and full and/or partial mesh.&nbsp; Contrary to traditional solutions which only allow for site to site or hub and spoke, Nutanix provides a fully mesh or flexible many-to-many model.</p>

<figure><img alt="Example Replication Topologies" class="iimagesv2dr_1png" src="imagesv2/dr_1.png" />
<figcaption>Example Replication Topologies</figcaption>
</figure>

<p>Essentially, this allows the admin to determine a replication capability that meets their company's needs.</p>

<h2>Implementation Constructs</h2>

<p>Within Nutanix DR, there are a few key constructs which are explained below:</p>

<h4>Remote Site</h4>

<ul>
	<li>Key Role: A remote Nutanix cluster</li>
	<li>Description: A remote Nutanix cluster which can be leveraged as a target for backup or DR purposes.</li>
	<li>cases,</li>
</ul>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>Ensure the target site has ample capacity (compute/storage) to handle a full site failure.&nbsp; In certain cases replication/DR between racks within a single site can also make sense.</p>
</div>

<h4>Protection Domain (PD)</h4>

<ul>
	<li>Key Role: Macro group of VMs and/or files to protect</li>
	<li>Description: A group of VMs and/or files to be replicated together on a desired schedule.&nbsp; A PD can protect a full container or you can select individual VMs and/or files</li>
	<li>(e.g.,</li>
</ul>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>Create multiple PDs for various services tiers driven by a desired RPO/RTO.&nbsp; For file distribution (e.g. golden images, ISOs, etc.) you can create a PD with the files to replication.</p>
</div>

<h4>Consistency Group (CG)</h4>

<ul>
	<li>Key Role: Subset of VMs/files in PD to be crash-consistent</li>
	<li>Description: VMs and/or files which are part of a Protection Domain which need to be snapshotted in a crash-consistent manner.&nbsp; This ensures that when VMs/files are recovered, they come up in a consistent state.&nbsp; A protection domain can have multiple consistency groups.</li>
	<li>Group-dependent(e.g.,</li>
</ul>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>Group dependent application or service VMs in a consistency group to ensure they are recovered in a consistent state (e.g. App and DB)</p>
</div>

<h4>Replication Schedule</h4>

<ul>
	<li>Key Role: Snapshot and replication schedule</li>
	<li>Description: Snapshot and replication schedule for VMs in a particular PD and CG</li>
</ul>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>The snapshot schedule should be equal to your desired RPO</p>
</div>

<h4>Retention Policy</h4>

<ul>
	<li>Key Role: Number of local and remote snapshots to keep</li>
	<li>Description: The retention policy defines the number of local and remote snapshots to retain.&nbsp; NOTE: A remote site must be configured for a remote retention/replication policy to be configured.</li>
	<li>VM/file.</li>
</ul>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>The retention policy should equal the number of restore points required per VM/file</p>
</div>

<p>The following figure shows a logical representation of the relationship between a PD, CG, and VM/Files for a single site:</p>

<figure><img alt="DR Construct Mapping" class="iimagesv2dr_2png" src="imagesv2/dr_2.png" />
<figcaption>DR Construct Mapping</figcaption>
</figure>

<p>It’s important to mention that a full container can be protected for simplicity; however the platform provides the ability to protect down to the granularity of a single VM and/or file level.</p>

<h2>Replication Lifecycle</h2>

<p>Nutanix replication leverages the Cerebro service mentioned above.&nbsp; The Cerebro service is broken into a “Cerebro Master”, which is a dynamically elected CVM, and Cerebro Slaves, which run on every CVM.&nbsp; In the event where the CVM acting as the “Cerebro Master” fails, a new “Master” is elected.</p>

<p>The Cerebro Master is responsible for managing task delegation to the local Cerebro Slaves as well as coordinating with remote Cerebro Master(s) when remote replication is occurring.</p>

<p>During a replication, the Cerebro Master will figure out which data needs to be replicated, and delegate the replication tasks to the Cerebro Slaves which will then tell Stargate which data to replicate and to where.</p>

<p>The following figure shows a representation of this architecture:</p>

<figure><img alt="Replication Architecture" class="iimagesv2dr_3png" src="imagesv2/dr_3.png" />
<figcaption>Replication Architecture</figcaption>
</figure>

<p>It is also possible to configure a remote site with a proxy which will be used as a bridgehead for all coordination and replication traffic coming from a cluster.</p>

<div data-type="note" class="note">
<h1>Pro Tip</h1>

<p>When using a remote site configured with a proxy, always utilize the cluster IP as that will always be hosted by the Prism Leader and available, even if CVM(s) go down.</p>
</div>

<p>The following figure shows a representation of the replication architecture using a proxy:</p>

<figure><img alt="Replication Architecture - Proxy" class="iimagesv2dr_4png" src="imagesv2/dr_4.png" />
<figcaption>Replication Architecture - Proxy</figcaption>
</figure>

<p>In certain scenarios, it is also possible to configure a remote site using a SSH tunnel where all traffic will flow between two CVMs.</p>

<div data-type="note" class="note">
<h1>Note</h1>
This should only be used for non-production scenarios and the cluster IPs should be used to ensure availability.</div>

<p>The following figure shows a representation of the replication architecture using a SSH tunnel:</p>

<figure><img alt="Replication Architecture - SSH Tunnel" class="iimagesv2dr_5png" src="imagesv2/dr_5.png" />
<figcaption>Replication Architecture - SSH Tunnel</figcaption>
</figure>

<h2>Global Deduplication</h2>

<p>As explained in the Elastic Deduplication Engine section above, DSF has the ability to deduplicate data by just updating metadata pointers. The same concept is applied to the DR and replication feature.&nbsp; Before sending data over the wire, DSF will query the remote site and check whether or not the fingerprint(s) already exist on the target (meaning the data already exists).&nbsp; If so, no data will be shipped over the wire and only a metadata update will occur. For data which doesn’t exist on the target, the data will be compressed and sent to the target site.&nbsp; At this point, the data exists on both sites is usable for deduplication.</p>

<p>The following figure shows an example three site deployment where each site contains one of more protection domains (PD):</p>

<figure><img alt="Replication Deduplication" class="iimagesv2dr_6png" src="imagesv2/dr_6.png" />
<figcaption>Replication Deduplication</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Note</h1>

<p>Fingerprinting must be enabled on the source and target container / vstore for replication deduplication to occur.</p>
</div>
</section>

<section data-type="sect1">
<h1>Cloud Connect</h1>

<p>Building upon the native DR / replication capabilities of DSF, Cloud Connect extends this capability into cloud providers (currently Amazon Web Services, or AWS).&nbsp; NOTE: This feature is currently limited to just backup / replication.</p>

<p>Very similar to creating a remote site to be used for native DR / replication, a “cloud remote site” is just created.&nbsp; When a new cloud remote site is created, Nutanix will automatically spin up an instance in EC2 (currently m1.xlarge) to be used as the endpoint.</p>

<p>The Amazon Machine Image (AMI) running in AWS is based upon the same NOS code-base leveraged for locally running clusters.&nbsp; This means that all of the native replication capabilities (e.g., global deduplication, delta based replications, etc.) can be leveraged.</p>

<p>In the case where multiple Nutanix clusters are leveraging Cloud Connect, they can either A) share the same AMI instance running in the region, or B) spin up a new instance.</p>

<p>The following figure shows a logical representation of an AWS based “remote site” used for Cloud Connect:</p>

<figure><img alt="Cloud Connect - Region" class="iimagesv2cloudconn_1png" src="imagesv2/cloudconn_1.png" />
<figcaption>Cloud Connect Region</figcaption>
</figure>

<p>Since an AWS based remote site is similar to any other Nutanix remote site, a cluster can replicate to multiple regions if higher availability is required (e.g., data availability in the case of a full region outage):</p>

<figure><img alt="Cloud Connect - Multi-region" class="iimagesv2cloudconn_2png" src="imagesv2/cloudconn_2.png" />
<figcaption>Cloud Connect Multi-region</figcaption>
</figure>

<p>The same replication / retention policies are leveraged for data replicated using Cloud Connect.&nbsp; As data / snapshots become stale, or expire, the Nutanix CVM in AWS will clean up data as necessary.</p>

<p>If replication isn’t frequently occurring (e.g., daily or weekly), the platform can be configured to power up the AWS CVM(s) prior to a scheduled replication and down after a replication has completed.</p>

<p>Data that is replicated to any AWS region can also be pulled down and restored to any existing, or newly created Nutanix cluster which has the AWS remote site(s) configured:</p>

<figure><img alt="Cloud Connect - Restore" class="iimagesv2cloudconn_3png" src="imagesv2/cloudconn_3.png" />
<figcaption>Cloud Connect - Restore</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Metro Availability</h1>

<p>Nutanix provides native “stretch clustering” capabilities which allow for a compute and storage cluster to span multiple physical sites.&nbsp; In these deployments, the compute cluster spans two locations and has access to a shared pool of storage.</p>

<p>This expands the VM HA domain from a single site to between two sites providing a near 0 RTO and a RPO of 0.</p>

<p>In this deployment, each site has its own Nutanix cluster, however the containers are “stretched” by synchronously replicating to the remote site before acknowledging writes.</p>

<p>The following figure shows a high-level design of what this architecture looks like:</p>

<figure><img alt="Metro Availability - Normal State" class="iimagesv2metro_1png" src="imagesv2/metro_1.png" />
<figcaption>Metro Availability - Normal State</figcaption>
</figure>

<p>In the event of a site failure, an HA event will occur where the VMs can be restarted on the other site.</p>

<p>The following figure shows an example site failure:</p>

<figure><img alt="Metro Availability - Site Failure" class="iimagesv2metro_2png" src="imagesv2/metro_2.png" />
<figcaption>Metro Availability - Site Failure</figcaption>
</figure>

<p>In the event where there is a link failure between the two sites, each cluster will operate independently.&nbsp; Once the link comes back up, the sites will be re-synchronized (deltas-only) and synchronous replication will start occurring.</p>

<p>The following figure shows an example link failure:</p>

<figure><img alt="Metro Availability - Link Failure" class="iimagesv2metro_3png" src="imagesv2/metro_3.png" />
<figcaption>Metro Availability - Link Failure</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Volumes API</h1>

<p>The Acropolis Volumes API exposes back-end DSF storage to external consumers (guest OS, physical hosts, containers, etc.) via iSCSI (today).</p>

<p>This allows any operating system to access DSF and leverage its storage capabilities.&nbsp; In this deployment scenario, the OS is talking directly to Nutanix bypassing any hypervisor.&nbsp;</p>

<p>Core use-cases for the Volumes API:</p>

<ul>
	<li>Shared Disks
	<ul>
		<li>Oracle RAC, Microsoft Failover Clustering, etc.</li>
	</ul>
	</li>
	<li>Disks as first-class entities
	<ul>
		<li>Where execution contexts are ephemeral and data is critical</li>
		<li>Containers, OpenStack, etc.</li>
	</ul>
	</li>
	<li>Guest-initiated iSCSI
	<ul>
		<li>Bare-metal consumers</li>
		<li>Exchange on vSphere (for Microsoft Support)</li>
	</ul>
	</li>
</ul>

<p>The following entities compose the volumes API:</p>

<ul>
	<li><strong>Volume Group:</strong> iSCSI target and group of disk devices allowing for centralized management, snapshotting, and policy application</li>
	<li><strong>Disks:</strong> Storage devices in the Volume Group (seen as LUNs for the iSCSI target)</li>
	<li><strong>Attachment:</strong> Allowing a specified initiator IQN access to the volume group</li>
</ul>

<p>NOTE: On the backend, a VG’s disk is just a vDisk on DSF.</p>

<p>To use the Volumes API, the following process is leveraged:</p>

<ol>
	<li>Create new Volume Group</li>
	<li>Add disk(s) to Volume Group</li>
	<li>Attach an initiator IQN to the Volume Group</li>
</ol>

<div data-type="example">
<h5>Create Volume Group</h5>

<p># Create VG</p>

<p>vg.create &lt;VG Name&gt;</p>

<p># Add disk(s) to VG</p>

<p>Vg.disk_create &lt;VG Name&gt; container=&lt;CTR Name&gt; create_size=&lt;Disk size, e.g. 500G&gt;</p>

<p># Attach initiator IQN to VG</p>

<p>Vg.attach_external &lt;VG Name&gt; &lt;Initiator IQN&gt;</p>
</div>

<p>The following figure shows an example with a VM running on Nutanix, with its OS hosted on the normal Nutanix storage, mounting the volumes directly:</p>

<figure><img alt="Volume API - Example" class="iimagesv2volapi_1png" src="imagesv2/volapi_1.png" />
<figcaption>Volume API - Example</figcaption>
</figure>

<p>In Windows deployments, iSCSI multi-pathing can be configured leveraging the Windows MPIO feature.&nbsp; It is recommended to leverage the ‘Failover only’ policy (default) to ensure vDisk ownership doesn’t change.</p>

<figure><img alt="MPIO Example - Normal State" class="iimagesv2volapi_2png" src="imagesv2/volapi_2.png" />
<figcaption>MPIO Example - Normal State</figcaption>
</figure>

<p>In the event there are multiple disk devices, each disk will have an active path to the local CVM:</p>

<figure><img alt="MPIO Example - Multi-disk" class="iimagesv2volapi_3png" src="imagesv2/volapi_3.png" />
<figcaption>MPIO Example - Multi-disk</figcaption>
</figure>

<p>In the event where the active CVM goes down, another path would become active and I/Os would resume:</p>

<figure><img alt="MPIO Example - Path Failure" class="iimagesv2volapi_4png" src="imagesv2/volapi_4.png" />
<figcaption>MPIO Example - Path Failure</figcaption>
</figure>

<p>In our testing, we’ve seen MPIO to take ~15-16 seconds to complete, which is within the Windows disk I/O timeout (default is 60 seconds).</p>

<p>If RAID or LVM is desired, the attached disk devices can be put into a dynamic or logical disk:</p>

<figure><img alt="RAID / LVM Example - Single-path" class="iimagesv2volapi_5png" src="imagesv2/volapi_5.png" />
<figcaption>RAID / LVM Example - Single-path</figcaption>
</figure>

<p>In the event where the local CVM is under heavy utilization, it is possible to have active paths to other CVMs.&nbsp; This will balance the I/O load across multiple CVMs, however will take a hit by having to traverse the network for the primary I/O:</p>

<figure><img alt="RAID / LVM Example - Multi-path" class="iimagesv2volapi_6png" src="imagesv2/volapi_6.png" />
<figcaption>RAID / LVM Example - Multi-path</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Networking and I/O</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/Bz37Eu_TgxY">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//Bz37Eu_TgxY"></iframe></div>

<p>The Nutanix platform does not leverage any backplane for inter-node communication and only relies on a standard 10GbE network.&nbsp; All storage I/O for VMs running on a Nutanix node is handled by the hypervisor on a dedicated private network.&nbsp; The I/O request will be handled by the hypervisor, which will then forward the request to the private IP on the local CVM.&nbsp; The CVM will then perform the remote replication with other Nutanix nodes using its external IP over the public 10GbE network. For all read requests, these will be served completely locally in most cases and never touch the 10GbE network. This means that the only traffic touching the public 10GbE network will be DSF remote replication traffic and VM network I/O.&nbsp; There will, however, be cases where the CVM will forward requests to other CVMs in the cluster in the case of a CVM being down or data being remote.&nbsp; Also, cluster-wide tasks, such as disk balancing, will temporarily generate I/O on the 10GbE network.</p>

<p>The following figure shows an example of how the VM’s I/O path interacts with the private and public 10GbE network:</p>

<figure class="large"><img alt="DSF Networking" class="iimagesv2net_iopng" src="imagesv2/net_io.png" />
<figcaption>DSF Networking</figcaption>
</figure>

<p>&nbsp;</p>
</section>

<section data-type="sect1">
<h1>Data Locality</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/ocLD5nBbUTU">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//ocLD5nBbUTU"></iframe></div>

<p>Being a converged (compute+storage) platform, I/O and data locality are critical to cluster and VM performance with Nutanix.&nbsp; As explained above in the I/O path, all read/write IOs are served by the local Controller VM (CVM) which is on each hypervisor adjacent to normal VMs.&nbsp; A VM’s data is served locally from the CVM and sits on local disks under the CVM’s control.&nbsp; When a VM is moved from one hypervisor node to another (or during a HA event), the newly migrated VM’s data will be served by the now local CVM. When reading old data (stored on the now remote node/CVM), the I/O will be forwarded by the local CVM to the remote CVM.&nbsp; All write I/Os will occur locally right away.&nbsp; DSF will detect the I/Os are occurring from a different node and will migrate the data locally in the background, allowing for all read I/Os to now be served locally.&nbsp; The data will only be migrated on a read as to not flood the network.</p>

<p>The following figure shows an example of how data will “follow” the VM as it moves between hypervisor nodes:</p>

<figure class="large"><img alt="Data Locality" class="iimagesv2data_locality2png" src="imagesv2/data_locality2.png" />
<figcaption>Data Locality</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Thresholds for Data Migration</h1>

<p>Data locality is a real-time operation and an extent group will be migrated when the following occurs:
"3 touches within a 10 minute window where multiple reads every 10 second sampling count as a single touch".
</p>
</div>

</section>

<section data-type="sect1">
<h1>Shadow Clones</h1>

<p>For a visual explanation, you can watch the following video: <a href="https://youtu.be/oqfFDMYQFJg">LINK</a></p>

<div class="video-container"><iframe allowfullscreen="" frameborder="0" src="https://www.youtube.com/embed//oqfFDMYQFJg"></iframe></div>

<p>The Acropolis Distributed Storage Fabric has a feature called ‘Shadow Clones’, which allows for distributed caching of particular vDisks or VM data which is in a ‘multi-reader’ scenario.&nbsp; A great example of this is during a VDI deployment many ‘linked clones’ will be forwarding read requests to a central master or ‘Base VM’.&nbsp; In the case of VMware View, this is called the replica disk and is read by all linked clones, and in XenDesktop, this is called the MCS Master VM.&nbsp; This will also work in any scenario which may be a multi-reader scenario (e.g., deployment servers, repositories, etc.). Data or I/O locality is critical for the highest possible VM performance and a key struct of DSF.&nbsp;</p>

<p>With Shadow Clones, DSF will monitor vDisk access trends similar to what it does for data locality.&nbsp; However, in the case there are requests occurring from more than two remote CVMs (as well as the local CVM), and all of the requests are read I/O, the vDisk will be marked as immutable.&nbsp; Once the disk has been marked as immutable, the vDisk can then be cached locally by each CVM making read requests to it (aka Shadow Clones of the base vDisk). This will allow VMs on each node to read the Base VM’s vDisk locally. In the case of VDI, this means the replica disk can be cached by each node and all read requests for the base will be served locally.&nbsp; NOTE:&nbsp; The data will only be migrated on a read as to not flood the network and allow for efficient cache utilization.&nbsp; In the case where the Base VM is modified, the Shadow Clones will be dropped and the process will start over.&nbsp; Shadow clones are enabled by default (as of 4.0.2) and can be enabled/disabled using the following NCLI command: ncli cluster edit-params enable-shadow-clones=&lt;true/false&gt;.</p>

<p>The following figure shows an example of how Shadow Clones work and allow for distributed caching:</p>

<figure class="large"><img alt="Shadow Clones" class="iimagesv2shadow_clonepng" src="imagesv2/shadow_clone.png" />
<figcaption>Shadow Clones</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>Storage Layers and Monitoring</h1>

<p>The Nutanix platform monitors storage at multiple layers throughout the stack, ranging from the VM/Guest OS all the way down to the physical disk devices.&nbsp; Knowing the various tiers and how these relate is important whenever monitoring the solution and allows you to get full visibility of how the ops relate. The following figure shows the various layers of where operations are monitored and the relative granularity which are explained below:</p>

<figure><img alt="Storage Layers" class="iimagesv2storage_layerspng" src="imagesv2/storage_layers.png" />
<figcaption>Storage Layers</figcaption>
</figure>

<p>&nbsp;</p>

<h2>Virtual Machine Layer</h2>

<ul>
	<li>Key Role: Metrics reported by the hypervisor for the VM</li>
	<li>Description: Virtual Machine or guest level metrics are pulled directly from the hypervisor and represent the performance the VM is seeing and is indicative of the I/O performance the application is seeing.</li>
	<li>When to use: When troubleshooting or looking for VM level detail</li>
</ul>

<h2>Hypervisor Layer</h2>

<ul>
	<li>Key Role: Metrics reported by the Hypervisor(s)</li>
	<li>Description: Hypervisor level metrics are pulled directly from the hypervisor and represent the most accurate metrics the hypervisor(s) are seeing.&nbsp; This data can be viewed for one of more hypervisor node(s) or the aggregate cluster.&nbsp; This layer will provide the most accurate data in terms of what performance the platform is seeing and should be leveraged in most cases.&nbsp; In certain scenarios the hypervisor may combine or split operations coming from VMs which can show the difference in metrics reported by the VM and hypervisor.&nbsp; These numbers will also include cache hits served by the Nutanix CVMs.</li>
	<li>When to use: Most common cases as this will provide the most detailed and valuable metrics.</li>
</ul>

<h2>Controller Layer</h2>

<ul>
	<li>Key Role: Metrics reported by the Nutanix Controller(s)</li>
	<li>Description: Controller level metrics are pulled directly from the Nutanix Controller VMs (e.g.,&nbsp;Stargate 2009 page) and represent what the Nutanix front-end is seeing from NFS/SMB/iSCSI or any back-end operations (e.g., ILM, disk balancing, etc.).&nbsp; This data can be viewed for one of more Controller VM(s) or the aggregate cluster.&nbsp; The metrics seen by the Controller Layer should normally match those seen by the hypervisor layer, however will include any backend operations (e.g., ILM, disk balancing). These numbers will also include cache hits served by memory.&nbsp; In certain cases, metrics like (IOPS), might not match as the NFS / SMB / iSCSI client might split a large IO into multiple smaller IOPS.&nbsp; However, metrics like bandwidth should match.</li>
	<li>When to use: Similar to the hypervisor layer, can be used to show how much backend operation is taking place.</li>
</ul>

<h2>Disk Layer</h2>

<ul>
	<li>Key Role: Metrics reported by the Disk Device(s)</li>
	<li>Description: Disk level metrics are pulled directly from the physical disk devices (via the CVM) and represent what the back-end is seeing.&nbsp; This includes data hitting the OpLog or Extent Store where an I/O is performed on the disk.&nbsp; This data can be viewed for one of more disk(s), the disk(s) for a particular node, or the aggregate disks in the cluster.&nbsp; In common cases, it is expected that the disk ops should match the number of incoming writes as well as reads not served from the memory portion of the cache.&nbsp; Any reads being served by the memory portion of the cache will not be counted here as the op is not hitting the disk device.</li>
	<li>When to use: When looking to see how many ops are served from cache or hitting the disksm</li>
</ul>

<div data-type="note" class="note">
<h1>Metric and Stat Retention</h1>

<p>Metrics and time series data is stored locally for 90 days in Prism Element.  For Prism Central and Insights, data can be stored indefinitely (assuming capacity is available).</p>
</div>
</section>
</section>

<section data-type="chapter">
<h1>Application Mobility Fabric - coming soon!</h1>

<p>More coming soon!</p>
</section>

<section data-type="chapter">
<h1>Acropolis Hypervisor</h1>

<section data-type="sect1">
<h1>Node Architecture</h1>

<p>In Acropolis Hypervisor deployments, the Controller VM (CVM) runs as a VM and disks are presented using PCI passthrough.&nbsp; This allows the full PCI controller (and attached devices) to be passed through directly to the CVM and bypass the hypervisor.&nbsp; Acropolis Hypervisor is based upon CentOS KVM.</p>

<figure><img alt="Acropolis Hypervisor Node" class="iimagesv2acrop_nodepng" src="imagesv2/acrop_node.png" />
<figcaption>Acropolis Hypervisor Node</figcaption>
</figure>

<p>The Acropolis Hypervisor is built upon the CentOS KVM foundation and extends its base functionality to include features like HA, live migration, etc.&nbsp;</p>

<p>Acropolis Hypervisor is validated as part of the Microsoft Server Virtualization Validation Program and is validated to run Microsoft OS and applications.</p>
</section>

<section data-type="sect1">
<h1>KVM Architecture</h1>

<p>Within KVM there are a few main components:</p>

<ul>
	<li>KVM-kmod
	<ul>
		<li>KVM kernel module</li>
	</ul>
	</li>
	<li>Libvirtd
	<ul>
		<li>An API, daemon and management tool for managing KVM and QEMU.&nbsp; Communication between Acropolis and KVM / QEMU occurs through libvirtd.</li>
	</ul>
	</li>
	<li>Qemu-kvm
	<ul>
		<li>A machine emulator and virtualizer that runs in userspace for every Virtual Machine (domain).&nbsp; In the Acropolis Hypervisor it is used for hardware-assisted virtualization and VMs run as HVMs.</li>
	</ul>
	</li>
</ul>

<p>The following figure shows the relationship between the various components:</p>

<figure><img alt="KVM Component Relationship" class="iimagesv2kvm_overviewpng" src="imagesv2/kvm_overview.png" />
<figcaption>KVM Component Relationship</figcaption>
</figure>

<p>Communication between Acropolis and KVM occurs via Libvirt.&nbsp;</p>

<div data-type="note" class="note">
<h1>Processor generation compatability</h1>

<p>Similar to VMware's Enhanced vMotion Capability (EVC) which allows VMs to move between different processor generations; Acropolis Hypervisor will determine the lowest processor generation in the cluster and constrain all QEMU domains to that level.  This allows mixing of processor generations within an AHV cluster and ensures the ability to live migrate between hosts.</p>
</div>

</section>

<section data-type="sect1">
<h1>Configuration Maximums and Scalability</h1>

<p>The following configuration maximums and scalability limits are applicable:</p>

<ul>
	<li>Maximum cluster size: <strong>N/A – same as Nutanix cluster size</strong></li>
	<li>Maximum vCPUs per VM: <strong>Number of physical cores per host</strong></li>
	<li>Maximum memory per VM: <strong>2TB</strong></li>
	<li>Maximum VMs per host: <strong>N/A – Limited by memory</strong></li>
	<li>Maximum VMs per cluster: <strong>N/A – Limited by memory</strong></li>
</ul>
</section>

<section data-type="sect1">
<h1>Networking</h1>

<p>Acropolis Hypervisor leverages Open vSwitch (OVS) for all VM networking.&nbsp; VM networking is configured through Prism / ACLI and each VM nic is connected into a tap interface.</p>

<p>The following figure shows a conceptual diagram of the OVS architecture:</p>

<figure><img alt="Open vSwitch Network Overview" class="iimagesv2acrop_netpng" src="imagesv2/acrop_net.png" />
<figcaption>Open vSwitch Network Overview</figcaption>
</figure>
</section>

<section data-type="sect1">
<h1>How It Works</h1>

<section data-type="sect2">
<h2>iSCSI Multi-pathing</h2>

<p>On each KVM host there is a iSCSI redirector daemon running which checks Stargate health throughout the cluster using NOP OUT commands.</p>

<p>QEMU is configured with the iSCSI redirector as the iSCSI target portal.&nbsp; Upon a login request, the redirector will perform and iSCSI login redirect to a healthy Stargate (preferably the local one).</p>

<figure><img alt="iSCSI Multi-pathing - Normal State" class="iimagesv2iscsi_mp_1png" src="imagesv2/iscsi_mp_1.png" />
<figcaption>iSCSI Multi-pathing - Normal State</figcaption>
</figure>

<p>In the event where the active Stargate goes down (thus failing to respond to the NOP OUT command), the iSCSI redirector will mark the local Stargate as unhealthy.&nbsp; When QEMU retries the iSCSI login, the redirector will redirect the login to another healthy Stargate.</p>

<figure><img alt="iSCSI Multi-pathing - Local CVM Down" class="iimagesv2iscsi_mp_2png" src="imagesv2/iscsi_mp_2.png" />
<figcaption>iSCSI Multi-pathing - Local CVM Down</figcaption>
</figure>

<p>Once the local Stargate comes back up (and begins responding to the NOP OUT commands), the iSCSI redirector will perform a TCP kill to kill all connections to remote Stargates.&nbsp; QEMU will then attempt an iSCSI login again and will be redirected to the local Stargate.</p>

<figure><img alt="iSCSI Multi-pathing - Local CVM Back Up" class="iimagesv2iscsi_mp_3png" src="imagesv2/iscsi_mp_3.png" />
<figcaption>iSCSI Multi-pathing - Local CVM Back Up</figcaption>
</figure>
</section>

<section data-type="sect2">
<h2>IP Address Management</h2>

<p>The Acropolis IP address management (IPAM) solution provides the ability to establish a DHCP scope and assign addresses to VMs.&nbsp; This leverages VXLAN and OpenFlow rules to intercept the DHCP request and respond with a DHCP response.</p>

<p>Here we show an example DHCP request using the Nutanix IPAM solution where the Acropolis Master is running locally:</p>

<figure><img alt="IPAM - Local Acropolis Master" class="iimagesv2acrop_ipam_1png" src="imagesv2/acrop_ipam_1.png" />
<figcaption>IPAM - Local Acropolis Master</figcaption>
</figure>

<p>If the Acropolis Master is running remotely, the same VXLAN tunnel will be leveraged to handle the request over the network.&nbsp;</p>

<figure><img alt="IPAM - Remote Acropolis Master" class="iimagesv2acrop_ipam_2png" src="imagesv2/acrop_ipam_2.png" />
<figcaption>IPAM - Remote Acropolis Master</figcaption>
</figure>

<p>Traditional DHCP / IPAM solutions can also be leveraged in an ‘unmanaged’ network scenario.</p>
</section>

<section data-type="sect2">
<h2>VM High Availability (HA)</h2>
<p>
	Acropolis hypervisor VM HA is a feature built to ensure VM availability in the event of a host or block outage.  In the event of a host failure the VMs previously running on that host will be restarted on other healthy nodes throughout the cluster.  The Acropolis Master is responsible for restarting the VM(s) on the healthy host(s).
</p>

<p>
	The Acropolis Master tracks host health by monitoring it's connections to the libvirt on all cluster hosts:
</p>

<figure><img alt="HA - Host Monitoring" src="imagesv2/ha_hostmonitoring.png" />
<figcaption>HA - Host Monitoring</figcaption>
</figure>

<p>
	In the event the Acropolis Master becomes partitioned, isolated or fails a new Acropolis Master will be elected on the healthy portion of the cluster.  If a cluster becomes partitioned (e.g X nodes can't talk to the other Y nodes) the side with quorum will remain up and VM(s) will be restarted on those hosts.
</p>

<div data-type="note" class="note">
<h1>Default VM restart policy</h1>
<p>
	By default any AHV cluster will do its best to restart VM(s) in the event of a host failure.  In this mode, when a host becomes unavailable, the previously running VMs will be restarted on the remaining healthy hosts if possible.  Since this is best effort (meaning resources aren't reserved) the ability to restart all VMs will be dependent on available AHV resources.
</p>
</div>

<p>
	There are two main types of resource reservations for HA:
</p>

<ul>
	<li>
		Reserve Hosts
		<ul>
			<li>
				Reserve X number of hosts where X is the number of host failures to tolerate (e.g. 1, 2, etc.)
			</li>
			<li>
				This is the default when all hosts with the same amount of RAM
			</li>
		</ul>
	</li>
	<li>
		Reserve Segments
		<ul>
			<li>
				Reserve Y resources across N hosts in the cluster.  This will be a function of the cluster FT level, the size of the running VMs and the number of nodes in the cluster.
			</li>
			<li>
				This is the default when some hosts have different amounts of RAM
			</li>
		</ul>
	</li>
</ul>

<div data-type="note" class="note">
<h1>Pro tip</h1>
<p>
	Use reserve hosts when:
</p>
<ul>
	<li>
		You have homogenous clusters (all hosts <strong>DO</strong> have the same amount of RAM)
	</li>
	<li>
		Consolidation ratio is higher priority than performance
	</li>
</ul>
<p>
	Use reserve segments when:
</p>
<ul>
	<li>
		You have heterogeneous clusters (all hosts <strong>DO NOT</strong> have the same amount of RAM)
	</li>
	<li>
		Performance is higher priority than consolidation ratio
	</li>
</ul>
</div>

<p>
	I'll cover both reservation options in the following sections.
</p>

<h3>Reserve Hosts</h3>

<p>
	  By default the number of failures to tolerate will be the same as the cluster FT level (i.e. 1 for FT1 aka RF2, 2 for FT2 aka RF3, etc.).  It is possible to override this via acli.
</p>

<div data-type="note" class="note">
<h1>Pro tip</h1>
<p>
	You can override or manually set the number of reserved failover hosts with the following ACLI command:
</p>
<p class="codetext">acli ha.update num_reserved_hosts=&lt;NUM_RESERVED&gt;</p>
</div>

<p>
	The figure shows an example scenario with a reserved host:
</p>

<figure><img alt="HA - Reserved Host" src="imagesv2/ha_reservedhost1.png" />
<figcaption>HA - Reserved Host</figcaption>
</figure>

<p>
	In the event of a host failure VM(s) will be restarted on the reserved host(s):
</p>

<figure><img alt="HA - Reserved Host - Fail Over" src="imagesv2/ha_reservedhost2.png" />
<figcaption>HA - Reserved Host - Fail Over</figcaption>
</figure>

<p>
	If the failed host comes back the VM(s) will be live migrated back to the original host to minimize any data movement for data locality:
</p>

<figure><img alt="HA - Reserved Host - Fail Back" src="imagesv2/ha_reservedhost3.png" />
<figcaption>HA - Reserved Host - Fail Back</figcaption>
</figure>

<h3>Reserve Segments</h3>
<p>
	Reserve segments distributes the resource reservation across all hosts in a cluster.  In this scenario, each host will share a portion of the reservation for HA.  This ensures the overall cluster has enough failover capacity to restart VM(s) in the event of a host failure.
</p>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>Keep your hosts balanced when using segment based reservation.  This will give the highest utilization and ensure not too many segments are reserved.</p>
</div>

<p>
	The figure shows an example scenario with reserved segments:
</p>

<figure><img alt="HA - Reserved Segment" src="imagesv2/ha_reservedsegment1.png" />
<figcaption>HA - Reserved Segment</figcaption>
</figure>

<p>
	In the event of a host failure VM(s) will be restarted throughout the cluster on the remaining healthy hosts:
</p>

<figure><img alt="HA - Reserved Segment - Fail Over" src="imagesv2/ha_reservedsegment2.png" />
<figcaption>HA - Reserved Segment - Fail Over</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Reserved segment(s) calculation</h1>
<p>
	The system will automatically calculate the total number of reserved segments and per host reservation.  To gain some insight on how this is calculated some details on the calculation can be found in the following text.
</p>

<p>
	Acropolis HA uses fixed size segments to reserve enough space for successful VM restart in case of host failure.  The segment size corresponds to largest VM in the system.  The distinctive feature of Acropolis HA is the ability to pack multiple smaller VMs into a single fixed size segment.  In a cluster with VMs of varying size, a single segment can accommodate multiple VMs, thus reducing fragmentation inherent to any fixed size segment scheme.
</p>

<p>
	The most efficient placement of VMs (least number of segments reserved) is defined as bin-packing problem, a well known problem in computer science.  The optimal solution is NP-hard (exponential), but heuristic solutions can come close to optimal for the common case.  Nutanix will continue improving its placement algorithms.  We expect to have 0.25 extra overhead for the common case in future versions. Today, the fragmentation overhead varies between 0.5 and 1 giving a total overhead of 1.5-2 per configured host failure.
</p>

<p>
	When using a segment based reservation there are a few key constructs that come in to play:
</p>

<ul>
	<li>
		Segment size = Largest running VM's memory footprint (GB)
	</li>
	<li>
		Most loaded host = Host running VMs with most memory (GB)
	</li>
	<li>
		Fragmentation overhead = 0.5 - 1
	</li>
</ul>

<p>
	Based upon these inputs you can calculate the expected number of reserved segments:
</p>

<ul>
	<li>
		Reserved segments = (Most loaded host / Segment size) x (1 + Fragmentation overhead)
	</li>
</ul>
</div>

</section>
</section>

<section data-type="sect1">
<h1>Administration</h1>

<p>More coming soon!</p>
</section>

<section data-type="sect1">
<h1>Important Pages</h1>

<p>More coming soon!</p>
</section>

<section data-type="sect1">
<h1>Command Reference</h1>

<h2>Enable 10GbE links only on OVS</h2>

<p class="codedescription">Description: Enable 10g only on bond0 for local host</p>

<p class="codetext">manage_ovs --interfaces 10g update_uplinks</p>
<p class="codedescription">Description: Show ovs uplinks for full cluster</p>
<p>
allssh "manage_ovs --interfaces 10g update_uplinks"
</p>

<h2>Show OVS uplinks</h2>

 <p class="codedescription">Description: Show ovs uplinks for local host</p>

<p class="codetext">manage_ovs show_uplinks</p>

 <p class="codedescription">Description: Show ovs uplinks for full cluster</p>

<p class="codetext">allssh "manage_ovs show_uplinks"</p>

<h2>Show OVS interfaces</h2>

 <p class="codedescription">Description: Show ovs interfaces for local host</p>

<p class="codetext">manage_ovs show_interfaces</p>

<p>Show interfaces for full cluster</p>

<p class="codetext">allssh "manage_ovs show_interfaces"</p>

<h2>Show OVS switch information</h2>

 <p class="codedescription">Description: Show switch information</p>

<p class="codetext">ovs-vsctl show</p>

<h2>List OVS bridges</h2>

 <p class="codedescription">Description: List bridges</p>

<p class="codetext">ovs-vsctl list br</p>

<h2>Show OVS bridge information</h2>

 <p class="codedescription">Description: Show OVS port information</p>

<p class="codetext">ovs-vsctl list port br0
<br/>
ovs-vsctl list port &lt;bond&gt;</p>

<h2>Show OVS interface information</h2>

 <p class="codedescription">Description: Show interface information</p>

<p class="codetext">ovs-vsctl list interface br0</p>

<h2>Show ports / interfaces on bridge</h2>

<p class="codedescription">Description: Show ports on a bridge</p>

<p class="codetext">ovs-vsctl list-ports br0</p>

<p class="codedescription">Description: Show ifaces on a bridge</p>

<p class="codetext">ovs-vsctl list-ifaces br0</p>

<h2>Create OVS bridge</h2>

<p class="codedescription">Description: Create bridge</p>

<p class="codetext">ovs-vsctl add-br &lt;bridge&gt;</p>

<h2>Add ports to bridge</h2>

 <p class="codedescription">Description: Add port to bridge</p>

<p class="codetext">ovs-vsctl add-port &lt;bridge&gt; &lt;port&gt;</p>

<p class="codedescription">Description: Add bond port to bridge</p>

<p class="codetext">ovs-vsctl add-bond &lt;bridge&gt; &lt;port&gt; &lt;iface&gt;</p>

<h2>Show OVS bond details</h2>

<p class="codedescription">Description: Show bond details</p>

<p class="codetext">ovs-appctl bond/show &lt;bond&gt;</p>

<p>Example:</p>

<p class="codetext">ovs-appctl bond/show bond0</p>

<h2>Set bond mode and configure LACP on bond</h2>

<p class="codedescription">Description: Enable LACP on ports</p>

<p class="codetext">ovs-vsctl set port &lt;bond&gt; lacp=&lt;active/passive&gt;</p>

<p class="codedescription">Description: Enable on all hosts for bond0</p>

<p class="codetext">for i in `hostips`;do echo $i; ssh $i source /etc/profile &gt; /dev/null 2&gt;&amp;1; ovs-vsctl set port bond0 lacp=active;done</p>

<h2>Show LACP details on bond</h2>

<p class="codedescription">Description: Show LACP details</p>

<p class="codetext">ovs-appctl lacp/show &lt;bond&gt;</p>

<h2>Set bond mode</h2>

<p class="codedescription">Description: Set bond mode on ports</p>

<p class="codetext">ovs-vsctl set port &lt;bond&gt; bond_mode=&lt;active-backup, balance-slb, balance-tcp&gt;</p>

<h2>Show OpenFlow information</h2>

<p class="codedescription">Description: Show OVS openflow details</p>

<p class="codetext">ovs-ofctl show br0</p>

<p class="codedescription">Description: Show OpenFlow rules</p>

<p class="codetext">ovs-ofctl dump-flows br0</p>

<h2>Get QEMU PIDs and top information</h2>

<p class="codedescription">Description: Get QEMU PIDs</p>

<p class="codetext">ps aux | grep qemu | awk '{print $2}'</p>

<p class="codedescription">Description: Get top metrics for specific PID</p>

<p class="codetext">top -p &lt;PID&gt;</p>

<h2>Get active Stargate for QEMU processes</h2>

<p class="codedescription">Description: Get active Stargates for storage I/O for each QEMU processes</p>

<p class="codetext">netstat –np | egrep tcp.*qemu</p>
</section>

<section data-type="sect1">
<h1>Metrics and Thresholds</h1>

<p>More coming soon!</p>
</section>

<section data-type="sect1">
<h1>Troubleshooting &amp; Advanced Administration</h1>

<h2>Check iSCSI Redirector Logs</h2>

<p class="codedescription">Description: Check iSCSI Redirector Logs for all hosts</p>

<p class="codetext">for i in `hostips`; do echo $i; ssh root@$i cat /var/log/iscsi_redirector;done</p>

<p>Example for single host</p>

<p class="codetext">Ssh root@&lt;HOST IP&gt;
<br/>
Cat /var/log/iscsi_redirector</p>

<h2>Monitor CPU steal (stolen CPU)</h2>

<p class="codedescription">Description: Monitor CPU steal time (stolen CPU)</p>

<p>Launch top and look for %st (bold below)</p>

<p class="codetext">Cpu(s):&nbsp; 0.0%us, 0.0%sy,&nbsp; 0.0%ni, 96.4%id,&nbsp; 0.0%wa,&nbsp; 0.0%hi,&nbsp; 0.1%si,&nbsp; <strong>0.0%st</strong></p>

<h2>Monitor VM network resource stats</h2>

<p class="codedescription">Description: Monitor VM resource stats</p>

<p>Launch virt-top</p>

<p class="codetext">Virt-top</p>

<p>Go to networking page</p>

<p>2 – Networking</p>
</section>
</section>

<section data-type="chapter">
<h1>Administration</h1>

<section data-type="sect1">
<h1>Important Pages</h1>

<p>These are advanced Nutanix pages besides the standard user interface that allow you to monitor detailed stats and metrics.&nbsp; The URLs are formatted in the following way: http://&lt;Nutanix CVM IP/DNS&gt;:&lt;Port/path (mentioned below)&gt;&nbsp; Example: http://MyCVM-A:2009&nbsp; NOTE: if you’re on a different subnet IPtables will need to be disabled on the CVM to access the pages.</p>

<h2>2009 Page</h2>

<p>This is a Stargate page used to monitor the back end storage system and should only be used by advanced users.&nbsp; I’ll have a post that explains the 2009 pages and things to look for.</p>

<h2>2009/latency Page</h2>

<p>This is a Stargate page used to monitor the back end latency.</p>

<h2>2009/vdisk_stats Page</h2>

<p>This is a Stargate page used to show various vDisk stats including histograms of I/O sizes, latency, write hits (e.g., OpLog, eStore), read hits (cache, SSD, HDD, etc.) and more.</p>

<h2>2009/h/traces Page</h2>

<p>This is the Stargate page used to monitor activity traces for operations.</p>

<h2>2009/h/vars Page</h2>

<p>This is the Stargate page used to monitor various counters.</p>

<h2>2010 Page</h2>

<p>This is the Curator page which is used for monitoring Curator runs.</p>

<h2>2010/master/control Page</h2>

<p>This is the Curator control page which is used to manually start Curator jobs</p>

<h2>2011 Page</h2>

<p>This is the Chronos page which monitors jobs and tasks scheduled by Curator.</p>

<h2>2020 Page</h2>

<p>&nbsp;This is the Cerebro page which monitors the protection domains, replication status and DR.</p>

<h2>2020/h/traces Page</h2>

<p>This is the Cerebro page used to monitor activity traces for PD operations and replication.</p>

<h2>2030 Page</h2>

<p>This is the main Acropolis page and shows details about the environment hosts, any currently running tasks and networking details..</p>

<h2>2030/sched Page</h2>

<p>This is an Acropolis page used to show information about VM and resource scheduling used for placement decisions.&nbsp; This page shows the available host resources and VMs running on each host.</p>

<h2>2030/tasks Page</h2>

<p>This is an Acropolis page used to show information about Acropolis tasks and their state.&nbsp; You can click on the task UUID to get detailed JSON about the task.</p>

<h2>2030/vms Page</h2>

<p>This is an Acropolis page used to show information about Acropolis VMs and details about them.&nbsp; You can click on the VM Name to connect to the console.</p>
</section>

<section data-type="sect1">
<h1>Cluster Commands</h1>

<h2>Check cluster status</h2>

<p class="codedescription">Description: Check cluster status from the CLI</p>

<p class="codetext">cluster status</p>

<h2>Check local CVM service status</h2>

<p class="codedescription">Description: Check a single CVM's service status from the CLI</p>

<p class="codetext">genesis status</p>

<h2>Nutanix cluster upgrade</h2>

<p class="codedescription">Description: Perform rolling (aka "live") cluster upgrade from the CLI</p>

<p>Upload upgrade package to ~/tmp/ on one CVM</p>

<p>Untar package</p>

<p class="codetext">tar xzvf ~/tmp/nutanix*</p>

<p>Perform upgrade</p>

<p class="codetext">~/tmp/install/bin/cluster -i ~/tmp/install upgrade</p>

<p>Check status</p>

<p class="codetext">upgrade_status</p>

<h2>Node(s) upgrade</h2>

<p class="codedescription">Description: Perform upgrade of specified node(s) to current clusters version</p>

<p>From any CVM running the desired version run the following command:</p>

<p class="codetext">cluster -u &lt;NODE_IP(s)&gt; upgrade_node</p>

<h2>Hypervisor upgrade status</h2>

<p class="codedescription">Description: Check hypervisor upgrade status from the CLI on any CVM</p>

<p class="codetext">host_upgrade --status</p>

<p>Detailed logs (on every CVM)</p>

<p class="codetext">~/data/logs/host_upgrade.out</p>

<h2>Restart cluster service from CLI</h2>

<p class="codedescription">Description: Restart a single cluster service from the CLI</p>

<p>Stop service</p>

<p class="codetext">cluster stop &lt;Service Name&gt;</p>

<p>Start stopped services</p>

<p class="codetext">cluster start&nbsp; #NOTE: This will start all stopped services</p>

<h2>Start cluster service from CLI</h2>

<p class="codedescription">Description: Start stopped cluster services from the CLI</p>

<p>Start stopped services</p>

<p class="codetext">cluster start&nbsp; #NOTE: This will start all stopped services</p>

<p>OR</p>

<p>Start single service</p>

<p class="codetext">Start single service: cluster start&nbsp; &lt;Service Name&gt;</p>

<h2>Restart local service from CLI</h2>

<p class="codedescription">Description: Restart a single cluster service from the CLI</p>

<p>Stop Service</p>

<p class="codetext">genesis stop &lt;Service Name&gt;</p>

<p>Start Service</p>

<p class="codetext">cluster start</p>

<h2>Start local service from CLI</h2>

<p class="codedescription">Description: Start stopped cluster services from the CLI</p>

<p class="codetext">cluster start #NOTE: This will start all stopped services</p>

<h2>Cluster add node from cmdline</h2>

<p class="codedescription">Description: Perform cluster add-node from CLI</p>

<p class="codetext">ncli cluster discover-nodes | egrep "Uuid" | awk '{print $4}' | xargs -I UUID ncli cluster add-node node-uuid=UUID</p>

<h2>Find number of vDisks</h2>

<p class="codedescription">Description: Displays the number of vDisks</p>

<p class="codetext">vdisk_config_printer | grep vdisk_id | wc -l</p>

<h2>Find cluster id</h2>

<p class="codedescription">Description: Find the cluster ID for the current cluster</p>

<p class="codetext">zeus_config_printer | grep cluster_id</p>

<h2>Open port</h2>

<p class="codedescription">Description: Enable port through IPtables</p>

<p class="codetext">sudo vi /etc/sysconfig/iptables
<br/>
-A INPUT -m state --state NEW -m tcp -p tcp --dport &lt;PORT&gt; -j ACCEPT
<br/>
sudo service iptables restart</p>

<h2>Check for Shadow Clones</h2>

<p class="codedescription">Description: Displays the shadow clones in the following format:&nbsp; name#id@svm_id</p>

<p class="codetext">vdisk_config_printer | grep '#'</p>

<h2>Reset Latency Page Stats</h2>

<p class="codedescription">Description: Reset the Latency Page (&lt;CVM IP&gt;:2009/latency) counters</p>

<p class="codetext">allssh "wget $i:2009/latency/reset"</p>

<h2>Find Number of vDisks</h2>

<p class="codedescription">Description: Find the current number of vDisks (files) on DSF</p>

<p class="codetext">vdisk_config_printer | grep vdisk_id | wc -l</p>

<h2>Start Curator scan from CLI</h2>

<p class="codedescription">Description: Starts a Curator full scan from the CLI</p>

<p class="codetext">allssh "wget -O - "http://$i:2010/master/api/client/StartCuratorTasks?task_type=2";"</p>

<h2>Compact ring</h2>

<p class="codedescription">Description: Compact the metadata ring</p>

<p class="codetext">allssh "nodetool -h localhost compact"</p>

<h2>Find NOS version</h2>

<p class="codedescription">Description: Find the NOS&nbsp; version (NOTE: can also be done using NCLI)</p>

<p class="codetext">allssh "cat /etc/nutanix/release_version"</p>

<h2>Find CVM version</h2>

<p class="codedescription">Description: Find the CVM image version</p>

<p class="codetext">allssh "cat /etc/nutanix/svm-version"</p>

<h2>Manually fingerprint vDisk(s)</h2>

<p class="codedescription">Description: Create fingerprints for a particular vDisk (For dedupe)&nbsp; NOTE: dedupe must be enabled on the container</p>

<p class="codetext">vdisk_manipulator –vdisk_id=&lt;vDisk ID&gt; --operation=add_fingerprints</p>

<h2>Echo Factory_Config.json for all cluster nodes</h2>

<p class="codedescription">Description: Echos the factory_config.jscon for all nodes in the cluster</p>

<p class="codetext">allssh "cat /etc/nutanix/factory_config.json"</p>

<h2>Upgrade a single Nutanix node’s NOS version</h2>

<p class="codedescription">Description: Upgrade a single node's NOS version to match that of the cluster</p>

<p class="codetext">~/cluster/bin/cluster -u &lt;NEW_NODE_IP&gt; upgrade_node</p>

<h2>&nbsp;List files (vDisk) on DSF</h2>

<p class="codedescription">Description: List files and associated information for vDisks stored on DSF</p>

<p class="codetext">Nfs_ls</p>

<p>Get help text</p>

<p class="codetext">Nfs_ls --help</p>

<h2>Install Nutanix Cluster Check (NCC)</h2>

<p class="codedescription">Description: Installs the Nutanix Cluster Check (NCC) health script to test for potential issues and cluster health</p>

<p>Download NCC from the Nutanix Support Portal (portal.nutanix.com)</p>

<p>SCP .tar.gz to the /home/nutanix directory</p>

<p>Untar NCC .tar.gz</p>

<p class="codetext">tar xzmf &lt;ncc .tar.gz file name&gt; --recursive-unlink</p>

<p>Run install script</p>

<p class="codetext">./ncc/bin/install.sh -f &lt;ncc .tar.gz file name&gt;</p>

<p>Create links</p>

<p class="codetext">source ~/ncc/ncc_completion.bash
<br/>
echo "source ~/ncc/ncc_completion.bash" &gt;&gt; ~/.bashrc</p>

<h2>Run Nutanix Cluster Check (NCC)</h2>

<p class="codedescription">Description: Runs the Nutanix Cluster Check (NCC) health script to test for potential issues and cluster health.&nbsp; This is a great first step when troubleshooting any cluster issues.</p>

<p>Make sure NCC is installed (steps above)</p>

<p>Run NCC health checks</p>

<p class="codetext">ncc health_checks run_all</p>
</section>

<section data-type="sect1">
<h1>Metrics and Thresholds</h1>

<p>The following section will cover specific metrics and thresholds on the Nutanix back end.&nbsp; More updates to these coming shortly!</p>
</section>

<section data-type="sect1">
<h1>Gflags</h1>

<p>More coming soon!</p>
</section>

<section data-type="sect1">
<h1>Troubleshooting &amp; Advanced Administration</h1>

<h2>Find Acropolis logs</h2>

<p class="codedescription">Description: Find Acropolis logs for the cluster</p>

<p class="codetext">allssh "cat ~/data/logs/Acropolis.log"</p>

<h2>Find cluster error logs</h2>

<p class="codedescription">Description: Find ERROR logs for the cluster</p>

<p class="codetext">allssh "cat ~/data/logs/&lt;COMPONENT NAME or *&gt;.ERROR"</p>

<p>Example for Stargate</p>

<p class="codetext">allssh "cat ~/data/logs/Stargate.ERROR"</p>

<h2>Find cluster fatal logs</h2>

<p class="codedescription">Description: Find FATAL logs for the cluster</p>

<p class="codetext">allssh "cat ~/data/logs/&lt;COMPONENT NAME or *&gt;.FATAL"</p>

<p>Example for Stargate</p>

<p class="codetext">allssh "cat ~/data/logs/Stargate.FATAL"</p>

<h2>Using the 2009 Page (Stargate)</h2>

<p>In most cases Prism should be able to give you all of the information and data points you require. &nbsp;However,&nbsp;in certain scenarios, or if you want some more detailed data you can leverage the Stargate aka 2009 page. &nbsp;The 2009 page can be viewed by navigating to &lt;CVM IP&gt;:2009.</p>

<div data-type="note" class="note">
<h1>Accessing back-end pages</h1>

<p>If you're on a different network segment (L2 subnet)&nbsp;you'll need to add a rule in IP tables to access any of the back-end pages.</p>
</div>

<p>At the top of the page is the overview details which show various details about the cluster:</p>

<figure><img alt="2009 Page - Stargate Overview" class="iimagesv22009pagesstargate_overview2png" src="imagesv2/2009Pages/stargate_overview2.png" />
<figcaption>2009 Page - Stargate Overview</figcaption>
</figure>

<p>In this section there are two key areas I look out for, the first being the I/O queues which shows the number of admitted / outstanding operations.</p>

<p>The figure shows the queues portion of the overview section:</p>

<figure><img alt="2009 Page - Stargate Overview - Queues" class="iimagesv22009pagesstargate_io_queuespng" src="imagesv2/2009Pages/stargate_io_queues.png" />
<figcaption>2009 Page - Stargate Overview - Queues</figcaption>
</figure>

<p>The second portion is the content cache details which shows information on cache sizes and hit rates.</p>

<p>The figure shows the content cache portion of the overview section:</p>

<figure><img alt="2009 Page - Stargate Overview - Content Cache" class="iimagesv22009pagesstargate_contentcache2png" src="imagesv2/2009Pages/stargate_contentCache2.png" />
<figcaption>2009 Page - Stargate Overview - Content Cache</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>In ideal cases the hit rates should be above 80-90%+ if the workload is read heavy for the best possible read performance.</p>
</div>

<p>NOTE: these values are per Stargate / CVM</p>

<p>The next section is the 'Cluster State' which shows details on the various Stargates in the cluster and their disk usages.</p>

<p>The figure shows the Stargates and disk utilization&nbsp;(available/total):</p>

<figure class="large"><img alt="2009 Page - Cluster State - Disk Usage" class="iimagesv22009pagesstargate_diskutilpng" src="imagesv2/2009Pages/stargate_diskUtil.png" />
<figcaption>2009 Page - Cluster State - Disk Usage</figcaption>
</figure>

<p>The next section is the 'NFS Slave' section which will show various details and stats per vDisk.</p>

<p>The figure shows the vDisks and various I/O details:</p>

<figure class="large"><img alt="2009 Page - NFS Slave - vDisk Stats" class="iimagesv22009pagesstargate_vdiskstatpng" src="imagesv2/2009Pages/stargate_vdiskStat.png" />
<figcaption>2009 Page - NFS Slave - vDisk Stats</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>When looking at any potential performance issues I always look at the following:</p>

<ol>
	<li>Avg. latency</li>
	<li>Avg. op size</li>
	<li>Avg. outstanding</li>
</ol>

<p>For more specific details the vdisk_stats page holds a plethora of information.</p>
</div>

<h2>Using the 2009/vdisk_stats Page</h2>

<p>The 2009 vdisk_stats page is a detailed page which provides even further data points per vDisk. &nbsp;This page includes details and a histogram of items like randomness, latency histograms, I/O sizes and working set details.</p>

<p>You can navigate to the vdisk_stats page by clicking on the 'vDisk Id' in the left hand column.</p>

<p>The figure shows the section and hyperlinked vDisk Id:</p>

<figure class="large"><img alt="2009 Page - Hosted vDisks" class="iimagesv22009pagesstargate_hostedvdiskbriefpng" src="imagesv2/2009Pages/stargate_hostedVdiskBrief.png" />
<figcaption>2009 Page - Hosted vDisks</figcaption>
</figure>

<p>This will bring you to the vdisk_stats page which will give you the detailed vDisk stats. &nbsp;NOTE: Theses values are real-time and can be updated by refreshing the page.</p>

<p>The first key area is the 'Ops and Randomness' section which will show a breakdown of whether the I/O patterns are random or sequential in nature.</p>

<p>The figure shows the 'Ops and Randomness' section:</p>

<figure><img alt="2009 Page - vDisk Stats - Ops and Randomness" class="iimagesv22009pagesstargate_opsrandomnesspng" src="imagesv2/2009Pages/stargate_opsRandomness.png" />
<figcaption>2009 Page - vDisk Stats - Ops and Randomness</figcaption>
</figure>

<p>The next area shows a histogram of the frontend read and write I/O latency&nbsp;(aka the latency the VM / OS sees).</p>

<p>The figure shows the 'Frontend Read Latency' histogram:</p>

<figure class="large"><img alt="2009 Page - vDisk Stats - Frontend Read Latency" class="iimagesv22009pagesstargate_readlat_fepng" src="imagesv2/2009Pages/stargate_readLat_FE.png" />
<figcaption>2009 Page - vDisk Stats - Frontend Read Latency</figcaption>
</figure>

<p>The figure shows the 'Frontend Write Latency' histogram:</p>

<figure class="large"><img alt="2009 Page - vDisk Stats - Frontend Write Latency" class="iimagesv22009pagesstargate_writelat_fepng" src="imagesv2/2009Pages/stargate_writeLat_FE.png" />
<figcaption>2009 Page - vDisk Stats - Frontend Write Latency</figcaption>
</figure>

<p>The next key area is the I/O size distribution which shows a histogram of the read and write I/O sizes.</p>

<p>The figure shows the 'Read Size Distribution' histogram:</p>

<figure class="large"><img alt="2009 Page - vDisk Stats - Read I/O Size" class="iimagesv22009pagesstargate_readsizepng" src="imagesv2/2009Pages/stargate_readSize.png" />
<figcaption>2009 Page - vDisk Stats - Read I/O Size</figcaption>
</figure>

<p>The figure shows the 'Write Size Distribution'&nbsp;histogram:</p>

<figure class="large"><img alt="2009 Page - vDisk Stats - Write I/O Size" class="iimagesv22009pagesstargate_writesizepng" src="imagesv2/2009Pages/stargate_writeSize.png" />
<figcaption>2009 Page - vDisk Stats - Write I/O Size</figcaption>
</figure>

<p>The next key area is the 'Working Set Size' section which provides insight on working set sizes for the last 2 minutes and 1 hour. &nbsp;This is broken down for both read and write I/O.</p>

<p>The figure shows the 'Working Set Sizes' table:</p>

<figure><img alt="2009 Page - vDisk Stats - Working Set" class="iimagesv22009pagesstargate_workingsetpng" src="imagesv2/2009Pages/stargate_workingSet.png" />
<figcaption>2009 Page - vDisk Stats - Working Set</figcaption>
</figure>

<p>The 'Read Source' provides details on which tier or location the read I/O are being served from.</p>

<p>The figure shows the 'Read Source' details:</p>

<figure><img alt="2009 Page - vDisk Stats - Read Source" class="iimagesv22009pagesstargate_readsourcepng" src="imagesv2/2009Pages/stargate_readSource.png" />
<figcaption>2009 Page - vDisk Stats - Read Source</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>If you're seeing high read latency take a look at the read source for the vDisk and take a look where the I/Os are being served from. &nbsp;In most cases high latency could be caused by reads coming from HDD (Estore HDD).</p>
</div>

<p>The 'Write Destination' section will show where the new write I/O are coming in to.</p>

<p>The figure shows the 'Write Destination' table:</p>

<figure><img alt="2009 Page - vDisk Stats - Write Destination" class="iimagesv22009pagesstargate_writedestpng" src="imagesv2/2009Pages/stargate_writeDest.png" />
<figcaption>2009 Page - vDisk Stats - Write Destination</figcaption>
</figure>

<div data-type="note" class="note">
<h1>Pro tip</h1>

<p>Random or smaller I/Os (&lt;64K) will be written to the Oplog. &nbsp;Larger or sequential I/Os will bypass the Oplog and be directly written to the Extent Store (Estore).</p>
</div>

<p>Another interesting data point is what data is being up-migrated from HDD to SSD via ILM. &nbsp;The 'Extent Group Up-Migration' table shows data that has been up-migrated in the last 300, 3,600 and 86,400 seconds.</p>

<p>The figure shows the 'Extent Group Up-Migration' table:</p>

<figure><img alt="2009 Page - vDisk Stats - Extent Group Up-Migration" class="iimagesv22009pagesstargate_egroupilmpng" src="imagesv2/2009Pages/stargate_eGroupILM.png" />
<figcaption>2009 Page - vDisk Stats - Extent Group Up-Migration</figcaption>
</figure>

<h2>Using the 2010 Page (Curator)</h2>

<p>The 2010 page is a detailed page for monitoring the Curator MapReduce framework. &nbsp;This page provides details on jobs, scans, and associated tasks.&nbsp;</p>

<p>You can navigate to the Curator page by navigating to http://&lt;CVM IP&gt;:2010. &nbsp;NOTE: if you're not on the Curator Master click on the IP hyperlink after 'Curator Master: '. &nbsp;</p>

<p>The top of the page will show various details about the Curator Master including uptime, build version, etc.</p>

<p>The next section is the 'Curator Nodes' table which shows various details about the nodes in the cluster, the roles, and health status. &nbsp;These will be the nodes Curator leverages for the distributed processing and delegation of tasks.</p>

<p>The figure shows the 'Curator Nodes' table:</p>

<figure><img alt="2010 Page - Curator Nodes" class="iimagesv22010pagescurator_nodes2png" src="imagesv2/2010Pages/curator_nodes2.png" />
<figcaption>2010 Page - Curator Nodes</figcaption>
</figure>

<p>The next section is the 'Curator Jobs' table which shows the completed or currently running jobs. &nbsp;</p>

<p>There are two main types of jobs which include a partial scan which is eligible to run every 60 minutes and a full scan which is eligible to run every 6 hours. &nbsp;NOTE: the timing will be variable based upon utilization and other activities.</p>

<p><span style="letter-spacing: 0.01em; line-height: 1.3em;">These scans will run on their periodic schedules however can also be triggered by certain cluster events.</span></p>

<p>Here are some of the reasons for a jobs execution:</p>

<ul>
	<li>Periodic (normal state)</li>
	<li>Disk / Node / Block failure</li>
	<li>ILM Imbalance</li>
	<li>Disk / Tier Imbalance</li>
</ul>

<p>The figure shows the 'Curator Jobs' table:</p>

<figure><img alt="2010 Page - Curator Jobs" class="iimagesv22010pagescurator_jobs2png" src="imagesv2/2010Pages/curator_jobs2.png" />
<figcaption>2010 Page - Curator Jobs</figcaption>
</figure>

<p>The table shows some of the high-level activities performed by each job:</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 100%;">
	<caption>Curator Scan Tasks</caption>
	<thead>
		<tr>
			<th scope="col"><strong>Activity</strong></th>
			<th scope="col"><strong>Full Scan</strong></th>
			<th scope="col"><strong>Partial Scan</strong></th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<th scope="row">ILM</th>
			<td>X</td>
			<td>X</td>
		</tr>
		<tr>
			<th scope="row">Disk Balancing</th>
			<td>X</td>
			<td>X</td>
		</tr>
		<tr>
			<th scope="row">Compression</th>
			<td>X</td>
			<td>X</td>
		</tr>
		<tr>
			<th scope="row">Deduplication</th>
			<td>X</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<th scope="row">Erasure Coding</th>
			<td>X</td>
			<td>&nbsp;</td>
		</tr>
		<tr>
			<th scope="row">Garbage Cleanup</th>
			<td>X</td>
			<td>&nbsp;</td>
		</tr>
	</tbody>
</table>

<p>Clicking on the 'Execution id' will bring you to the job details page which displays various job stats as well as generated tasks.</p>

<p>The table at the top of the page will show various details on the job including the type, reason, tasks and duration.</p>

<p>The next section is the 'Background Task Stats' table which displays various details on the type of tasks, quantity generated and priority.</p>

<p>The figure shows the job details table:</p>

<figure><img alt="2010 Page - Curator Job - Details" class="iimagesv22010pagesjob_details2png" src="imagesv2/2010Pages/job_details2.png" />
<figcaption>2010 Page - Curator Job - Details</figcaption>
</figure>

<p>The figure shows the 'Background Task Stats' table:</p>

<figure><img alt="2010 Page - Curator Job - Tasks" class="iimagesv22010pagesjob_tasks2png" src="imagesv2/2010Pages/job_tasks2.png" />
<figcaption>2010 Page - Curator Job - Tasks</figcaption>
</figure>

<p>The next section is the 'MapReduce Jobs' table which shows the actual MapReduce jobs started by each Curator job. &nbsp;Partial scans will have a single MapReduce Job, full scans will have four MapReduce Jobs.</p>

<p>The figure shows the 'MapReduce Jobs' table:</p>

<figure class="large"><img alt="2010 Page - MapReduce Jobs" class="iimagesv22010pagescurator_mrjobs2png" src="imagesv2/2010Pages/curator_mrjobs2.png" />
<figcaption>2010 Page - MapReduce Jobs</figcaption>
</figure>

<p>Clicking on the 'Job id' will bring you to the MapReduce job details page which displays the tasks status,&nbsp;various counters and details about the MapReduce job.</p>

<p>The figure shows a sample of some of the job counters:</p>

<figure><img alt="2010 Page - MapReduce Job - Counters" class="iimagesv22010pagesjob_counters2png" src="imagesv2/2010Pages/job_counters2.png" />
<figcaption>2010 Page - MapReduce Job - Counters</figcaption>
</figure>

<p>The next section on the main page is the 'Queued Curator Jobs' and 'Last Successful Curator Scans' section. These tables show when the periodic scans are eligible to run and the last successful scan's details.</p>

<p>The figure shows the&nbsp;'Queued Curator Jobs' and 'Last Successful Curator Scans' section:</p>

<figure class="large"><img alt="2010 Page - Queued and Successful Scans" class="iimagesv22010pagescurator_queue_lastsuccessful2png" src="imagesv2/2010Pages/curator_queue_lastsuccessful2.png" />
<figcaption>2010 Page - Queued and Successful Scans</figcaption>
</figure>
</section>
</section>
</div>
